---
title: 事件绑定
date: 2020-04-01
updated: 2019-05-03
tags: JavaScript
categories: JavaScript
keywords: JavaScript
description: JavaScript 事件绑定
top_img:
comments: false
cover:
toc:
toc_number:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---

# DOM事件

## 基础知识

```js
1. 事件是浏览器赋予元素的默认行为 也可以理解为事件 是天生具备的 不论我们是否为其绑定方法 当某些行为触发的时候 相关的事件都会被执行
2. 事件绑定 给元素默认的事件行为 绑定方法 可以在行为触发的时候 执行这个方法
```

## 常用事件

```js
1. 鼠标事件 
click 点击事件(pc) 单击事件(移动端 300ms 内没有发生第二次点击操作 算作单机事件行为 所以click在移动端 有300ms 延迟)
dblclick 双击事件
contextmenu 鼠标右键点击触发
mousedown 鼠标按下 
mouseup 鼠标抬起   
mousemove 鼠标移动
mouseover 鼠标滑入
mouseout 鼠标滑出
mouseenter 鼠标进入
mouseleave 鼠标离开
mousewheel 鼠标滚轮
2. 键盘事件
keydown 键盘按下
keyup 键盘抬起
keypress 长按 除了shift fn capslock
3. 手指事件
「touch event 单手指事件模型」 
touchstart 手指按下
touchmove 手指移动
touchend 手指松开
「Gesture Event 多手指事件模型」
4. 表单事件
focus 获取焦点
blur 失去焦点
submit 提交事件 表单元素都包含在form 并且点击的按钮 是submit
reset 表单重置 表单元素要包含在form
select 下拉框内容选中
change 内容改变
input 移动端经常使用的 监控文本框中的内容随着输入的改变而出发
5. 资源事件
load 加载成功 window.onload / img.onload
error 加载失败
beforeunload 资源卸载之前 window.onbeforedunload 页面关闭之前触发
6. CSS3动画事件
transitionend transition动画结束
transitionstart transition动画开始
transitionrun transition动画运行中
7.视图事件 
resize 元素 或者浏览器 大小改变
scroll 滚动条滚动
```

## DOM 0 级事件绑定

```js
1. 语法 元素.on[事件] = [函数] document.body.onclick= function(){}
2. 移除 赋值为null 或者其他非函数值即可 document.body.onclick =  null
3. 原理 每一个DOM 元素对象的私有属性上 有很多 类似于 onxxx的私有属性 我们给这些代表事件的私有属性赋值 就是DOM0级绑定
4. 如果没有对应事件私有属性(onDOMContentLoaded)则无法基于这种办法给事件赋值 只能给当前某个事件行为 绑定一个方法 如果绑定多个方法 最后一个操作会覆盖以前的
5. 好处是 执行效率快 而且开发者使用起来也很方便
```

## DOM 2 级事件绑定

```js
1.语法
2. 一般不是用匿名函数去绑定 因为没办法移除
3. 每一恶搞DOM元素都会基于__proto__ 查找到EventTarget.prototype上的 addEventlistener / removeEventlistener 等方法 基于这些方法实现事件
4. 凡是浏览器提供的事件行为 都可以基于这种模式完成事件绑定和移除
5. 可以绑定多个方法
```

```js
[元素].addEventListener([事件],[方法],[捕获/冒泡])
document.body.addEventListener('click',fn1,false)
移除 但是需要参数和绑定的时候一样
[元素].removeEventListener([事件],[方法],[捕获/冒泡])
```

## 事件对象

```js
1. 给当前元素 的某个事件行为 绑定方法 当事件行为触发 不仅会把方法执行 而且还会给方法默认传递一个实参 这个实参 就是我们的事件对象
2. 事件对象 就是存储当前事件操作及触发的相关信息的 这个信息是浏览器记录的
```

```js
//鼠标
let body = document.body
body.onclick = function (ev) {
  console.log(ev)
  // 输出 鼠标事件对象 MouseEvent 以下会有一些对象下的属性是我们常用的
  clientX/clientY 鼠标触发点距离当前窗口的 X / Y 轴坐标
  pageX/pageY 鼠标点距离body的 X / Y 轴的坐标 因为我们的body可能卷出去
  type 事件类型
  target / srcElement 获取当前事件源(当前操作的元素)
  path 记录的是 传播路径
  preventDefault() / returnValur = false 阻止默认行为
  stopPropagation() / canceBubble = true 组织冒泡传播
}
```

```js
//键盘
document.onkeydown = function (ev) {
  console.log(ev)
  // 输出 键盘事件对象 KeyboardEvent 
  witch / keyCode 获取键盘按键码
  key 存储按键名称
  altKey 是否按下alt键(主要用来组合按钮使用)
  ctrlKey 是否按下ctrl键(主要用来组合按钮使用)
}
```

```js
//手指
document.body.ontouchstart = function (ev){
  let point = ev.changedTouches[0]
  console.log(point) // 是一个对象 里面记录的是第一个手指的信息 比如离屏幕的坐标等等 和pc基本上一致
  console.log(ev)
  // 输出手指事件对象(移动端)
  changedTouches / targetTouches / touches 都是用来记录手指信息
  changedTouches 手指按下 移动 离开屏幕 都存储了手指的信息 哪怕离开屏幕后 记录最后一次
  touches 同上 不过 最后一次 手指信息 就不会被记录了
  最后获取的结果 获取的都是一个TouchList 记录每一根手指的信息
  ev.changedTouches[0] 第一根手指信息
}
```

## 事件对象的组织默认行为

```js
1. 浏览器会赋予元素很多的默认行为
鼠标右键菜单
点击a标签跳转页面
部分浏览器会记录输入记录 下次再一次输入的时候会有模糊匹配
键盘按下 会输入内容
2. 以上种种默认行为 我们都可以基于 ev.preventDefault() 来阻止这些默认行为
```

## 自定义右键菜单

```js
1.正常情况我们 我们点击鼠标右键 会弹出浏览器默认的右键菜单 所以我们首先要组织默认行为
2. 然后创建我们的自己的元素 其实很简单 就是 div 和 li 然后 让我们创建的div 定位到我们鼠标的位置 通过事件对象我们可以拿到 鼠标的坐标
3. 然后点击空白出的时候 我们需要销毁我们的自己创建的元素 让菜单消失 这里我们需要判断你点击的是 是不是我们创建的li 如果不是 就让菜单销毁
4. 我们需要判断 你点击的事件源 是不是你的li 如果是 我们就让我们的事件源 和事件标签 等于 我们上一层 也就是ul 直到最后外层 我们就什么也不干
```

```js
//1. 首先我们要监听鼠标的右键 这里我们需要给body去监听 然后 要组织它的默认行为
// 为了组织浏览器右键自己的菜单出现
document.body.oncontextmenu = function (ev) {
    // 组织浏览器右键自己弹出来菜单
    ev.preventDefault()
    //2. 先看看能不能获取到这个菜单元素
    let contextmenu = document.querySelector('#contextmenu')
    //3.如果获取不到 我们就自己创建一个菜单
    if(!contextmenu){
        //创建元素
        contextmenu = document.createElement('div')
        //赋值id
        contextmenu.id = 'contextmenu'
        const html = `<ul>
                <li>菜单一</li>
                <li>菜单二</li>
                <li>菜单三</li>
            </ul>`
        contextmenu.innerHTML = html
        //插入到body中
        document.body.appendChild(contextmenu)
    }
    //获取鼠标的 x y 轴地址
    const x = ev.clientX
    const y = ev.clientY
    //把菜单的位置 改变
    contextmenu.style.top = y+ 10 + 'px'
    contextmenu.style.left = x + 10 +'px'
}
//4. 点击空白的时候 要移除我们上面创建的元素 这里需要注意
// 首先 我们点空白处 要移除我们创建的元素 
// 其次 我们如果点击到 我们的菜单了 是不能移除了
// 这里点击的时候 我们能拿到它点击的事件源头 比如 你是点击的是也看上的哪个元素
window.onclick = function(ev){
    //5.比如此时你点击的是 body 那么就是body 如果是li 那么就是li
   let target = ev.target
   //拿到具体的事件源的标签
   let targetTag = target.tagName
   //6. 如果你点击的是li 那么我们肯定不能移除元素
   if(targetTag === 'LI'){
       //我们就让我们的点击事件源向上找一层 是ul
       target = targetTag.parentNode
       targetTag = target.tagName
   }
   //7. 然后我们继续向上找 直到你不我们的创建的元素位置
   if(targetTag === 'UL' && target.parentNode.id === 'contextmenu'){
        return
   }
   //8.否则 让右侧菜单消失 
   let contextmenu = document.querySelector('#contextmenu')
   if(contextmenu){
       document.body.removeChild(contextmenu)
   }
}
```

```js
1. 代码 地址 https://github.com/wazer1987/contextmenu
```

## 事件传播机制

```js
1. 我们页面上 有 window document body html 然后body 里面还有我们写的一些元素
2. 这些元素上 都有浏览器的赋予他们的事件 比如click等等 
3. 直到我们给他赋予事件处理函数的时候 这些事件都会被触发
4. 首先 他会冲 window 开始 一层一层向下寻找 看看 是我们哪个元素触发的事件 这个阶段我们 称之为 捕获阶段(CAPTURING_PHASE) 捕获阶段会记录你查找的路径 也就是e.path
5. 其次 找到之后 就会触发我们的事件处理函数 这个阶段我们 称之为 目标阶段(AT_TARGET)
6. 最后 事件处理完毕之后 会按照我们的捕获阶段获取的路径 一层一层在向上触发(如果在这个路径上某个元素绑定了事件处理函数 也会被执行) 这个阶段叫做冒泡(BUBBLING_PHASE)
7. DOM 0级 事件绑定中给元素事件行为绑定的方法 都是在目标阶段/冒泡阶段触发的
```

![](/Users/笔记/笔记/事件绑定/事件绑定1.jpg)

```js
let box = document.querySelector('.box')
let outer = document.querySelector('.outer')
let inner = document.querySelector('.inner')
inner.onclick = function (ev){
  ev.stopPropagation()
}
outer.onclick = function (ev){
  ev.stopPropagation()
}
inner.onclick = function (ev){
  ev.stopPropagation()
}
```

### 事件委托

```js
1. 以上我们阻止了冒泡 但是这样并不好 最起码写了三个函数 开辟了三个堆内存
2. 因为点击事件存在冒泡传播机制 所以不论点击 inner/outer/box 最后都会传播到BODY上 触发BODY click 事件行为 把为期绑定的方法执行
3. 在方法执行接受到的事件对象中 有一个target属性(事件源) 可以知道当前操作的是谁 我们方法中可以根据事件源的不同 我们做不同的处理
4. 我们把这种机制叫作事件委托 或 事件代理
```

```js
document.body.click = function (ev) {
  let target = ev.target
  		targeClass = target.ClassName
  if(targeClass === 'inner') {
     	console.log('inner')
    	return
   }
  if(targeClass === 'outer') {
     	console.log('outer')
    	return
   }
  if(targeClass === 'box') {
     	console.log('box')
    	return
   }
}
```

## 鼠标滑入事件的区别

### mouseover 和 mouseout

```js
1.假设有盒子A 和 盒子B 盒子B 在盒子 A 里面
2.当我们对B使用 mouseover的时候 会触发事件mouseover 
3.当我们鼠滑入到B里面的时候 不太会触发B的mouseover时间 由于冒泡机制 还会触发A的mouseout 事件 
4.当我们鼠标 离开 B 盒子的时候 会触发 B 盒子的mouseout事件 由于冒泡机制的传播 还会触发 A盒子的mouseover事件
```

### mouseenter和mouseleave

```js
1.和我们的mouseover 和 mouseout正好相反
2. 如果进入 A和B的重叠区域。不会像上面一样频繁的触发冒泡的传播机制。
```


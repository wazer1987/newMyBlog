---
title: 发布订阅
date: 2020-04-27
updated: 2019-06-04
tags: JavaScript
categories: 设计模式
keywords: JavaScript
description: JavaScript 单例设计 发布订阅
top_img:
comments: false
cover:
toc:
toc_number:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---

# 设计模式

## 发布订阅设计模式

```js
1. 设计模式是一种思想 为的是更好的管理我们的代码
```

```js
1. 比如我现在要给一个Dom 元素 绑定多个 事件
2. 如果使用 DOM 0 级别绑定 就显得比较不太方便
3. 使用 DOM2级 去绑定 就有了事件池的概念
4. 但是 以上只支持 我们的浏览器 自己的内置事件 比如 click mouseEnter 之类的 如果我们自己定义的事件就不支持
5. 所以我们基于上述的思想 就可以 自己写个事件池 然后支持自己的自定义事件
```

## DOM 0级

```js
function fn1() {console.log(1)}
function fn2() {console.log(2)}
function fn2() {console.log(3)}
box.onclick = function () {
  fn1()
  fn2()
  fn3()
}
//  以上只是一个简单的例子 假如 我们 这三个方法 都不在一个 js文件里 你就需要分别的引入进来 然后在 我们的click函数里去写入 如果某一天我又增加了很多 所以 你就要不停的去引入文件 然后在我们的事件处理函数里 去填写执行的方法 这样在管理代码层面 我们是低效的
```

## DOM 2级

```js
function fn1() {console.log(1)}
box.addEventListener('click',fn1)

function fn2() {console.log(2)}
box.addEventListener('click',fn2)

function fn3() {console.log(3)}
box.addEventListener('click',fn3)

//这样 即使 分了很多文件 我们在代码管理层面上也好维护  他会按照你的代码顺序去执行
```

## 事件池

| 元素 | 事件类型 | 方法 | 阶段  |
| :--: | :------: | :--: | :---: |
| box  |  click   | Fn1  | False |
| box  |  click   | Fn2  | False |

## 自定义事件池

```js
1. 首先我们要有一个容器 也就是我们的事件池 
2. 然后会有 on 方法 向事件池中 去加入哪个事件
3. off方法 从事件中移除事件
4. fire方法 通知哪个方法执行
5. 所以我们要创建一个事件池 发布一个计划表 基于 on / off 向事件池中增删方法 订阅计划 / 任务 fire 就是达到条件 通知计划表中的订阅任务的执行
```

![1](/Users/笔记/笔记/设计模式/1.png)

## 基于单利模式编写事件发布订阅

```js
1. 首先我们要有一个池子 用来存放 我们的事件名称 和 事件名称里面对应的方法
2. 然后我们需要个添加的方法 on 用来 向我们的池子里添加 我们的自定义事件名称 和 对应你事件名称的方法
3. off 用来移除 我们的自定义事件 和对应的方法
4. fire 通知方法 用来 执行我们自定义事件名称 里面 所对应的方法
```

```js
//基于单例模式实现
let subscribe = (function () {
    //1.定义一个池子
    let pond = {}
    //2.关于事件池中方法的管理
    /*
    * @params
    * type : 自定义事件的名称
    * func : 你要执行的事件函数
    * params : 执行的时候传递的参数
    */
    const on = function (type,func) {
        //3.首先我们要知道池子中你的自定义事件名称是否存在 
        // 如果存在了 我们就什么也不做 
        //如果不存在 我们就应该把这个名称添加进去 并且让它的值等于一个空数组 方便存放我的们事件处理函数
        !pond.hasOwnProperty(type) ? pond[type] = [] :null
        //4. 下一步 如果你这个自定义事件里 已经有我们的事件处理函数了 我们需要去重 如果不存在我们就需要添加
        let arr = pond[type]
        //判断 你的事件处理函数 在不在里面 如果在就去重 如果不在就添加
        // if(arr.includes(func)) return
        for(let i = 0; i < arr.length; i++){
            if(arr[i] === func){
                return
            }
        }
        arr.push(func)
    }
    const off = function (type,func){
        //5.移除 
        // 如果 你穿进来的自定义名称 在我们的pond 里 那么我就开始移除你传过来的事件处理函数
        // 如果不在 我们就给一个空数组
        let arr = pond[type] || []
        for(let i = 0; i < arr.length; i++){
            // 找到相同的了 开始移除
            if(arr[i] === func){
                arr.splice(i,1)
                // 这里我们在添加的时候 就已经去重了 所以不会在重复了 这里我们就要把循环结束
                break
            }
        }
        // 更快捷的方法 就是过滤
        //arr = arr.filter(item => item !== func)
    }
    //6.通知方法执行
    const fire = function (type,...params) {
        //这是找到了 你上面 要执行的函数
        let arr = pond[type] || []
        arr = arr.slice(0)
        // arr.forEach(item => item(...params))
        for(let i = 0; i < arr.length; i++){
            // 然后让每一个函数执行 并且 把参数传入进去
            let item = arr[i]
            item(...params)
        }
    }
    return {
        on,
        off,
        fire
    }
})()
```

```js
//以上我们就写完了 但是存在如下问题
let box = document.getElementById('box')
box.onclick = function (e) {
    subscribe.fire('@aa',10,20,e)
}
function fn1(x,y,e) {
    console.log(x,y,e)
}
subscribe.on('@aa',fn1)
function fn2(){
    console.log(2)
    //这里 我们在触发fn2的时候 把fn1 和 fn2 删除
    //这里 我们第一次触发的的时候 fn1 和 fn2 应该还能触发
    // 但是 fn2 执行完毕之后 fn1 和 fn2 才会被删除
    // 但是 我们第一次触发的时候  fn1 和 fn2 fn5 还在 但是 fn3 和 fn4 却被删除了
    // 然后当我们点击第二次的时候 才恢复正常
    subscribe.off('@aa',fn1)
    subscribe.off('@aa',fn2)
}
subscribe.on('@aa',fn2)
function fn3(){
    console.log(3)
}
subscribe.on('@aa',fn3)
function fn4(){
    console.log(4)
}
subscribe.on('@aa',fn4)

function fn5(){
    console.log(5)
}
subscribe.on('@aa',fn5)
```

## 数组塌陷

```js
1. 我们在 fn2 函数里 在执行的时候 我们把 fn1 和 fn2 删除了
2. 所以我们第一次执行的时候 fn1 fn2 fn3 fn4 fn5 都应该被输出 第二次点击的时候 只输出 fn4 fn5 
3. 然后第一次执行的时候  删除了 fn3 fn4  而执行 fn1 fn2 fn5 
4. 第二次 执行的时候 才恢复正常 输出了 fn3 fn4 fn5 这种情况 叫数组塌陷
5. 数组塌陷 是 当我们 删除了数组中的某一些项 它后面的索引 会往前移
```

```js
const off = function (type,func){
        let arr = pond[type] || []
        for(let i = 0; i < arr.length; i++){
            if(arr[i] === func){
                arr.splice(i,1)
                break
            }
        }
    }
function fn2(){
    console.log(2)
    subscribe.off('@aa',fn1)
    subscribe.off('@aa',fn2)
}
//我们来理清循环顺序
i = 0 的时候 我们执行 fn1
i = 1 的时候 我们执行 fn2
当我们执行 fn2 的时候 正常代码执行完毕 然后 我们开始 删除 fn1 和 fn2 
原有的数组 
//索引       --->删除之后    //索引
[0,1,2,3,4]                [0,1,2]
// 对应的元素 --->删除之后    //对应的元素
[fn1,fn2,fn3,fn4,fn5]      [fn3,fn4,fn5]
//此时 i++
i = 2 然后我们执行索引对应的元素 fn5 所以 fn3 fn4 没有执行
// 第二次 执行的就会恢复了
```

```js
// 我们通知的时候 可以把我们池子 克隆一份
 //6.通知方法执行
    const fire = function (type,...params) {
        //这是找到了 你上面 要执行的函数
        let arr = pond[type] || []
        //为了防止数组塌陷 我们克隆一份
        arr.arr.slice(0)
        // arr.forEach(item => item(...params))
        for(let i = 0; i < arr.length; i++){
            // 然后让每一个函数执行 并且 把参数传入进去
            let item = arr[i]
            item(...params)
        }
    }
```

## 基于工厂模式创建编写事件发布订阅

```js
1. 工厂模式就是 我们的函数当作一个普通函数执行
2. 当普通函数执行的时候 也可以创造它的一个实例
3. jquery里面 大量的运用了这种思想
```

```js
1. 如何能让一个函数 当作一个普通函数执行 又能创建它的一个实例呢
```

```js
//1. 假如下面是我们的一个构造函数 我们希望它执行的时候 又能当作普通函数执行 又能创建它的一个实例
function Sub () {
  //6. 这样 当我们在调用 Sub() 的时候 我们其实是创建了init的一个实例 init的原型指向的却是 sub
  return new init()
}
//2.下面我们在准备一个函数 用来创造 Sub的实例
function init () {
  // init 函数上的实例
  this.arr = []
}
//3. 我们在Sub 的原型上 写几个方法
Sub.prototype = {
  constructor:Sub
  on:function(){},
  fire:function(){},
  off():{}
}
//4. 我们让我们init函数的原型 等于 我们 sub函数的原型
init.prototype = Sub.prototype
//5. 这样我们在 new init() 的时候 init的实例__proto__ 就指向 我们sub 的原型 prototype
```

```js
//基于构造函数 模式 编写 发布订阅
(function(){
    function Sub () {
        return new init()
    }
    function init () {
        this.pond = {}
    }
    Sub.prototype = {
        constructor:Sub,
        //发布的方法 就是向你的池子中添加方法
        on:function(type,func){
            !this.pond.hasOwnProperty(type)?this.pond[type] = [] : null
            var arr = this.pond[type]
            if(arr.includes(func)) return
            arr.push(func)
        },
        // 通知的方法 从池子中执行方法
        fire(type,...params){
            var arr = this.pond[type]
            arr = arr.slice(0)
            for(var i = 0; i < arr.length; i++){
                var item = arr[i]
                item = item(...params)
            }
        },
        // 移除池子中的方法
        off(type,func){
            var arr = this.pond[type]
            this.pond[type] = arr.filter( item => {
                return item !== func
            })
        }
    }
    init.prototype = Sub.prototype
    window.Sub = Sub
})()
```



```js
1. 命令式编程 每个步骤都自己来 优点 是 步骤可以把控 比如我们移除的时候使用的for循环 就是每一步做什么 都由我们自己编写 比如找到对应的函数 自己去手动移除
2. 函数是编程 每个步骤 都不用自己做 只关注结果 比如我们移除的时候 写的第二个便利方法 filter 你只需告诉我你要移除哪项 就可以 优点是 低内聚高耦合 把功能代码给你封装好了
3. 地址 https://github.com/wazer1987/subscribe/blob/main/subscribe.js
```


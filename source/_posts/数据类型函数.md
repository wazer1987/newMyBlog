---
title: 数据类型函数
date: 2019-03-31
updated: 2019-06-03
tags: JavaScript 
categories: JS高级
keywords: JS高级
description: JS高级
top_img:
comments: false
cover:
toc:
toc_number:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---

## 	数据类型

### 基本数据类型(原始值类型)

```js
1. number -> NaN/Infinity
2. string -> 单引号/双引号/反引号
3. boolean -> true / false
4. undefined
5. null
6. symbol -> 创建唯一值 
let val = Symbol('00') 
console.log(val === val) true 
console.log( Symbol('00') === Symbol('00')) false
7. bigint -> 在一个数值后面加n 就是bigint
```

### 引用数据类型(复杂类型)

```js
1. object {}普通对象 []数组对象 // 正则对象 日期对象 等等
2. function
```

## 代码的运行

### 基本数据类型

```js
1. 浏览器 之所以能够运行代码 是因为提供了一个供代码运行环境
2. 这个运行环境 -> 叫 栈内存 ECStack(Execution Context Stack)
3. 栈内存 就是在计算机中内存中分配出来的一块内存 用来执行我们的代码 
4. 代码的执行 分为 全局代码 函数中代码 私有块中的代码 不同的代码执行 都有自己的上下文(环境) 这个上下文环境 叫EC(Execution Context)
5. 当我们的代码开始执行的时候 一开始 就会生成一个 EC(G)的全局执行上下文环境 用来执行我们的全局代码 之后 这个环境会进栈 因为代码都是在我们的栈内存中执行的
6. 进栈之后 我们会创建VO(G) 全局变量对象 代码在当前上下文中执行的时候 创建的变量会存储在当前上下文中指定的变量对象中 所以变量对象 就是用来存储当前上下文中创建的变量的
7. 以上环境都好了 开始执行代码之前 要变量提升 / 词法解析 等一些列 然后才开始执行 代码
8. 赋值的详细步骤 var a = 12 
+ 创建一个值12 把它存储起来(基本数据类型是存储在栈内存中)
+ 声明一个变量 把它存储到当前上下文所属的变量对象中
+ 最后进行等号赋值(定义) 本质上也是一个指针指向的过程
```

![](1.bmp)

### 复杂数据类型

```js
1. 基本上前面几个步骤还是一样的 创建执行环境栈(GO) 创建全局变量对象 然后代码执行
2. 这里只不过 我们的数据类型是引用数据类型 不会直接存储在栈内存中 会开辟一个堆内存 用来存储自己的键值对 每一个堆内存都有一个16进制的地址
3. 在堆内存中分别存储键值对
4. 把16进制地址放到栈中 供变量调用
```

![](2.bmp)

### 小知识点

```js
obj['name'] -> 获取成员为name的属性值
obj[name] -> 把name变量存储的值 作为成员获取其属性值
对象的属性名 可以是字符串 symbol 数字/布尔/null/undefined 等基本数据类型值
对于普通的对象来讲 属性名不能是引用数据类型的值(比如对象)
优先级
var a = b =12 这个顺序是从右向左的
a.x = a = 12 //这种 a.x的优先级高也就让a.x = 12 先算 在算 a = 12
```

```js
//示例
va obj = {
    name:'xxx'
}
var o1 = {
    age:12
}
obj[o1] = 100
// 由于o1作为属性名 给了obj对象 但O1的值 是个对象 根据我们上面写的 会转换成字符串 所以打印出来是
obj{
    name:'xxx',
    "[object object]":100    
}
```

```js
//示例
var a = {}
b='0' c=0
a[b] = "珠峰" //相当于 a['0'] = 珠峰
a[c] = '培训' //相当于 a[0] = 培训
//刚刚我们讲过对象的属性名 字符串'0'和数字0 是一个效果 也会转换成为字符串
console.log(a[b]) //结果是 培训
```

```js
//示例
var a={},
    b=Symbol('1'),
    c=Symbol('1');  
//以上b和c都是 Symbol 都是唯一的 所以 b != c
a[b]='珠峰';
a[c]='培训';  
console.log(a[b]); //打印还是 培训
```

```js
//示例
var a={}, b={n:'1'}, c={m:'2'};  
a[b]='珠峰'; b是对象 变成属性名就是 a['[object object]'] = 珠峰
a[c]='培训'; c也是对象 变成属性名是 a['[object object]'] = 培训
console.log(a[b]); //培训
```

## 全局对象

```js
1. 浏览器在最开始加载代码的时候 不仅提供了一个栈内存 供代码执行 而且还默认开辟了一个堆内存 存储一些内置的属性和方法(GO Global Object)全局对象 这堆内存的地址给了window
2. 也就是说我们的全局变量对象上(VO)在刚开是的时候就有一个叫window的变量 指向了我们的GO 也就是我们上面说的那个堆内存
3. 我们刚刚知道在占执行期上下文的时候 还产生一个全局变量对象 用来存放我们的全局代码的变量 这个 跟我们的全局对象是两个概念 全局对象指的是我们的WINDOW
```

### 声明变量都做了什么

```js
1. 在全局上下文中 基于 var 和 function 声明的全局变量 也会给GO(window)中新增一个对象的私有属性(这里切记 基于var 和 function才会这样 如果是let const 声明的 就不会给window中添加私有属性)
2. 这个window中新增的私有属性 会和我们刚刚声明的全局变量 有 映射机制 一个变 另外一个也会变
```

```js
var a = 10 
//声明了一个全局变量a  给我们的window上也增加了一个私有属性a
console.log(a)
// 首先看看a是否为全局变量 如果是 按照全局变量处理 如果不是全局变量 再看看 是否是window中的一个属性 如果也不是 则报错 a is not defined
```

## 函数的底层运行机制

```js
var x = [12, 23];
function fn(y) {
    y[0] = 100;
    y = [100];
    y[1] = 200;
    console.log(y); //输出[100,200]
}
fn(x);
console.log(x); //[100,23]
```

### 创建函数

```js
1. 这里因为函数也是引用类型的数据 所以 我们在创建函数的时候 也就是声明函数的时候 还会开辟一块 堆内存  然后把地址存放在栈内存中 
2. 堆内存中 存放的是函数体里面的代码 会当作字符串 这里当然也有键值对的情况 创建好了之后就等着函数被调用了
3. 在创建的函数的时候 我们就已经声明了函数的作用域 指就是我们函数所在的上下文 
4. 比如我们上面的的代码 我们的函数 所处的上下文 就是EC(G)
5. 函数创建了 单步执行 就是相当于存放了一大堆的字符串 一点用都没有
```

![](3.bmp)

### 执行函数

```js
1. 函数执行的目的是 把之前创建的函数时候 在函数体中存储的代码字符串去执行
2. 首先会形成一个全新的私有的上下文 比如我们在全局代码执行的时候 会形成一个EC(G)的全局上下文 这里也是一样的
3. 自己私有的上下文 创建好了之后 还会生成一个自己私有的 私有变量对象控件 叫AO 这就就是存放我们的内部的私有变量 比如 形参 比如 在函数体内部 声明的变量
4. 然后开始进栈 准备执行 执行之前我还有好多事情去做
5. 初始化作用域链 作用域两是一个两端的结构 左边是当前函数执行的时候自己生成的上下文 右端是你函数创建的时候 所在的作用域  这样就可以说明 当我们查找变量的时候 先去自己的执行上下文 中去找 如果没有 就看看作用域链 去自己的作用域中去找 如果在没有 就接着向上找 
6. 初始化 this指向 初始化 arguments 形参赋值 变量提升 等
7. 然后执行
8. 执行完毕之后 为了优化栈内存 会把形成的私有上下文 出栈释放掉(GC浏览器垃圾回收机制)
```

![](2.png)

## 数据类型转换规则

### 把其他数据类型转换为number

```js
1. 特定需要转换为number的
 +Number([val])
 +parseInt/parseFloat([val])
2. 隐式转换(浏览器内部默认要先转为Number在进行计算)
  +isNaN([val])
  +数学运算
```

### 把其他数据类型转换为字符串

```js
1.能使用的方法 toString() String()
2.隐式转换 加号运算的时候 如果某一边出现字符串 则式字符串拼接 
把对象转换为数字 需要先toString()转换为字符串 在去转换为数字
```

### 把其他数据转换为布尔

```js
1. 基于以下方式可以把其他数据类型转换为布尔 !转换为布尔值后取反 boolean([val])
2. 隐式转换 在循环或者条件判断中 条件处理的结果就式布尔类型值
3. 规则 只有 0 NaN null undefined 空字符串 五个之转换会变成布尔
```

### 在==比较过程中 数据转换的规则

```js
1.类型一样的几个特点 
{} == {} false 对象比较的是堆内存中的地址
[] == [] false
NaN == NaN false
```

```js
2. 类型不一样的转换规则
null == undefined true 但是 null ==== undefined 结果是false(因为类型不一样)
剩下的null / undefined 和其他任何数据类型值都不相等
```

```js
3.字符串 == 对象  要先把对象转换为字符串
```

```js
4. 剩下的如果 == 两边数据类型不一样 都是要转换为 数字在进行比较
```

```js
//示例
[] == false 
对象 == 布尔 两边类型不相等 都转换为数字 
对象转换为数字 先转换为字符串(先基于valueOf获得原始值 如果没有在去toString) 在转换为数字 空数组变成字符串 为 空字符串 ''字符串转成数字为0 false转换为数字为0
```

### 对象转换为字符串

```js
1. {} 在转换为字符串的时候 为 "[object object]" 其余的都是用双引号包裹起来
2. 因为对象在转为字符串的时候 调取的toString方法 是调取Object.prototype.toString 而这个方法 是检测数据类型的
```

### 把其他类型转换为数字

```js
Number('') 0  Number('10') 10 Number('10px') NaN 
Number(true) 1 Number(false) 0 Number(null) 0
Number(undefined) NaN 
Number(Symbol(10)) //转不了symbol 报错
//对象变为数字 应该先valueOf获取原始值 如果没有原始值 在toString 变为字符串 最后把字符串变为数字
```

### parseInt机制

```js
1. 把转换的值先转换为字符串 
2. 机制就从字符串的左侧第一个字符串开始 查找有效数字字符 遇到非有效数字 就停止不在找了 把找到的有效数字字符转换为数字 一个都没有找到 结果是NaN
3. parseFloat 比 parseInt 多检测一个小数点
```

```js
//示例
parseInt('1.2px') // 1
parseInt('') //NaN 先从字符串左侧开始找到有限数字 如果找不到 就返回NaN 所以结果是NaN
Number('') //0
isNaN('') // false这个会隐式转换为Number 是 0 0 不是NaN 所以是fanlse
ParseInt(null)// NaN 先转换为字符串为 'null'然后从左侧第一个开始查找  找不到有限数字 结果是NaN
Number(null) // 0
isNaN(null) //false
parseInt('12px') // 12
Number('12px') //NaN
isNaN('12px')// true
isNaN(Number(!!Number(parseInt('0.8')))) //false
//parseInt('0.8') -> 0
//!!Number(0) -> false
//Number(false) -> 0
// isNaN(0) -> false 
typeof !parseInt(null) + !isNaN(null)
//!parseInt(null) -> !NaN -> true
//typeof true -> 'boolean'
// !isNaN(null) ->  isNaN(null) -> !false -> true 
// 'booleantrue'
```

```js
//示例
let result = 10 +  false + undefined + [] + 'Tencent'  + true + {}
10 + false => 10 + 0 =>10
10 + undefined => 10 + NaN => NaN
NaN + [] => NaN + '' => 'NaN'
//后面的 就都是字符串拼接了
'NaNTencentTencentTencenttrue[object object]'
```

### 小知识

```js
+ 号 即使一边出现字符串 或者对象 也不一定是字符串拼接 ++/+ 这种情况
console.log(++'10') //11
console.log(+'10') //number 10
{} + 0 //0 会把左边的{} 认为是一个代码块 不参与运算 只算+0
0 + {} //"0 [object object]"  这是数学运算
```

## 变量声明

```js
1. 变量声明一共有5种方案 var function let const import
2. let 和 const 声明的都是变量 const 声明的变量是不允许指针重新指向的(但是存储的值是可以改变的 比如 存储的值是引用数据类型 可以基于地址改变堆内存种的信息)
3. 我们赋值本身 就是指针关联或者指针指向的过程
```

```js
// var  和 let 的区别
 + var fuction 存在变量提升 let 和 const 不存在
 + 在相同的上下文种 let 是不允许重复声明的 (而且检测是否重复声明 是发生在词法解析阶段) 词法解析 -> 变量提升 -> 代码执行
 + 暂时性死区 (浏览器遗留的BUG) 基于typeof 检测一个未被声明的变量 不会报错 结果是undefined
 + 除了函数或者对象的大括号之外 如果括号中 出现let / const / function 则会产生块级私有上下文 当前块级上下文也只是对 let / const / function 他们声明的变量有作用
```

```js
//变量提升阶段
console.log(fn) // undefined
if( 1== 1){
    console.log(fn) //函数 私有的
    function fn() { console.log('ok')}
    fn = 12
    console.log(fn) //12
}
console.log(fn) //函数
老版本浏览器 不管条件是否成立 变量 和 函数都会提升 函数也会定义
新版本 不管条件是否成立 函数都会提升 但不会赋值(比如在判断体 循环体 代码块 ) 他只会进行声明 不会赋值和定义
如果以上的大括号种出现了function xxx(){} 此时当前大括号会形成一个私有的上下文 第一件事情 就是变量提升 他会把函数声明 加定义
```

![](函数的超级变态机制.png)

## 变量提升机制

```js
1. 变量提升发生在 当前上下文中 (全局/私有/块级) js代码自上而下执行之前浏览器会提前处理一些事情
2. 带var的 只会提前声明  带function的会 提前声明加定义 就是函数整体提升
3. 函数表达式的方式 var fn = function(){} 只是会吧fn的变量 提升
4. let 和 const  是不进行变量提升的 只有带var 和functiond的才会
5. 基于全局上下文中声明的变量 和函数 会映射到全局变量 window上一份 作为它的属性 一个修改 另外一个也修改
6. 不论条件是否成立 都要进行变量提升
```

```js
//具名话 针对于函数表达式 
1. 我们原本 函数表达式 后面会写一个 匿名函数 但是现在 我们写了一个AAA的名字
var func = function AAA(){
    //但是这个具名的话的函数名字 可以在自己的当前上下文执行
    //可以递归使用
    AAA()
}	
2. 但是这个名字 在全局 是没有作用的
AAA() //AAA调用 会报错
```

```JS
// let  和 const 没有 变量提升 所以 报错也不一样
console.log(a) // Cannot access 'a' before initialization
let a = 12
```

```js
// 不论条件是否成立 都要进行变量提升(细节点:条件中带function的在新版本浏览器中只会提前声明 不会在提前赋值了)
1. 这里 就是 你下面不管条件是否成立不成立 都要提升一个a变量
if(!('a' in window)){
    var a = 1
    function fn(){}
}
console.log(a)
[老版本 浏览器]
var a fn = 函数
[新版本 浏览器(IE10以上)]
var a fn
```

```js
fn()
function fn(){console.log(1)}
fn()
function fn(){console.log(2)}
fn()
var fn = function (){console.log(3)}
fn()
function fn(){console.log(4)}
fn()
function fn(){console.log(5)}
fn()
/* EC(G)
* 1. 首先函数整体提升 fn()都上去了
* 2. 当走到 var fn = function (){console.log(3)} 发现已经有fn的函数了  就先不处理
* 3. 然后代码开始执行 前三个fn调用输出 都是5 
* 4. 当走到 fn = function (){console.log(3)} 开始给fn函数重新赋值了 所以后三个输出都是3
*/
```

### 块级作用域的变量提升机制

```JS
1. 如果我们的代码 出现在了除函数 和 对象意外的花括号里面 那么就会产生一个块级上下文
2. 新版本浏览器中 如果出现在块级作用域里面的代码 那么变量只声明不复制
3. 当我们执行代码的时候 会产生映射机制 也就是出现在块级作用域里的变量声明 或者函数执行的 之前的代码 都会映射到全局 而之后的代码 都会是私有的
```

![](1-2.bmp)

### 形参默认值

```js
1. 如果我们的函数形参有默认值了 而且 我们函数里有var声明的了变量 那么这个声明的变量将会形成一个块级作用域
2. 如果是let 声明的变量 那么就会报错
3. 并且块级私有上下文的上级上下文 就是函数的私有上下文
```

![](1-4.png)

## 闭包作用域和高级编程技巧

```js
1. 一般情况下 函数执行完成之后 所有形成的私有上下文 都会出栈释放 私有上下文中的一切内容都会被销毁 主要是为了优化栈内存控件
2. 特殊情况 如果函数执行所形成上下文中 有一个东西(引用类型的空间地址) 被当前上下文 以外的事物所占用 那么当前上下文 是不能被释放的 上下文中的信息保留下来了(包含私有变量) 导致栈内存空间变大 如果返回的地址还会被执行一次 所以也临时不会释放 当 外部用完 就会释放
3. 函数每次执行 都会形成一个全新的私有上下文
```

```js
let x = 5
function fn (x){
    //这里的return 就当是在堆内存中又开辟了一个空间 把函数的地址返回了
    return function(y){
        console.log(y + (++x))
    }
}
let f = fn(6) //这里其实就是返回了一个地址 而这种就是我们上面所说的 特殊情况
f(7)
fn(8)(9)
f(10)
console.log(x)
```

![](闭包.png)

```js
let a = 0 b =0
function A (a) {
    //这种地址也会被引用 因为在大A是全局的变量 执行到这里的时候 我们相当于把A的地址又重新赋值了
    A = function(b){
        alert(a + b ++)
    }
    alert(a++)
}
 A(1) // 弹框1
 A(2) // 弹框4
```

![](闭包2.png)

```js
//示例
var buttonList = document.querySelectorAll('button');
/* 
// 实现不了的，为啥？
//  + 循环中的i是全局的，每一轮循环给对应元素的click绑定方法（创建函数 [存储代码字符串]，此时函数没有执行）
//  + 循环结束的时候，全局的i=5
//  + 点击某个按钮，执行之前绑定的函数：此时形成一个全新的私有上下文，它的上级上下文是全局上下文，函数代码执行的过程中，遇到变量i，但是i不是自己的私有变量，找到的是全局的i，全局的i是5
*/
for (var i = 0; i < buttonList.length; i++) {
    buttonList[i].onclick = function () {
        console.log(i, `我是第${i+1}个按钮~`);
    };
}
//最后每次点击按钮之后 打印出来的都是5
```

![](8.bmp)

```js
//解决
// 解决问题的思路：当点击事件触发，执行对应的函数，用到的i不要再向全局查找了；相当于自己形成一个上下文，而自己的上下文中，存储了你需要的i，存储的值是指定的索引即可  =>闭包的保存机制
// 弊端：循环多少次，就产生多少个闭包，非常消耗内存
 for (var i = 0; i < buttonList.length; i++) {
    // 每一轮循环都会把自执行函数执行，形成一个全新的私有上下文（一共形成了5个）
    //   + 把当前这一轮全局i的值作为实参，传递给当前形成的私有上下文中的形参n[私有变量]
    //   + 第一个私有上下文中的n=0，第二个私有上下文中的n=1 ....
    // 每一个形成的上下文中，创建的函数都被外部的元素对象的onclick占用了，所以形成了5个闭包
    // 当点击按钮执行函数的时候，遇到一个变量n，不是自己私有的，则找上级上下文（闭包）中的n，而n存储的值就是它的索引
    (function (n) {
        buttonList[n].onclick = function () {
            console.log(`我是第${n+1}个按钮~`);
        };
    })(i);
} 
```

```js
for (var i = 0; i < buttonList.length; i++) {
    buttonList[i].onclick = (function (i) {
        // i是每一轮形成的闭包中的私有变量，五个闭包中存储的值分别是0~4[索引]
        // 每一次都是把小函数返回，赋值给元素的点击事件，当点击元素的时候，执行返回的小函数
        return function () {
            console.log(`我是第${i+1}个按钮~`);
        };
    })(i);
} 
```

```js
// 还是基于“闭包的机制”，但是不是自己去执行函数构建，而是利用ES6中let产生的私有上下文实现
for (let i = 0; i < buttonList.length; i++) {
    // 第一轮循环 私有块1
    //   + 私有变量 i = 0
    //   + 当前私有上下文中的创建的一个函数被全局的元素对象的onclick占用了(闭包)
    // ....
    buttonList[i].onclick = function () {
        console.log(`我是第${i+1}个按钮~`);
    };
} 
```

### let 的 for 循环机制

```js
1. 循环第一轮 会形成一个父级的私有块上下文 循环结束后就会销毁
2. 父级块上下文 都会把变量 传送给下面的子集上下文
3. 然后开始循环 每一轮都会形成一个私有块上下文 由于被我们的click 占用 所以不会销毁
```

### 事件绑定解决方案

```JS
1. 无论闭包还是let 我们都是用闭包解决的
2. 还有第二种解决方案 给每个DOM对象加个自定义属性
3. 利用事件代理的机制（性能提高>=40%）
```

```js
 // 方案二：自定义属性（事先把一些信息存储到元素的身上，后期在一些其他的操作中，想要获取这些信息，直接基于元素的属性访问就可以拿到这些值） =>操作DOM的时代下，这种方案非常常用
for (var i = 0; i < buttonList.length; i++) {
    // 把当前按钮的索引存储在它的自定义属性上（每个按钮都是一个元素对象）
    buttonList[i].myIndex = i;
    buttonList[i].onclick = function () {
        // 给当前元素的某个事件绑定方法，当事件触发，方法执行的时候，方法中的this是当前点击的按钮
        console.log(`我是第${this.myIndex+1}个按钮~`);
    };
} 
```

```js
// 方案三：利用事件代理的机制（性能提高>=40%）
<button index="1">按钮1</button>
<button index="2">按钮2</button>
<button index="3">按钮3</button>
<button index="4">按钮4</button>
document.body.onclick = function (ev) {
    let target = ev.target;
    // 点击的是按钮
    if (target.tagName === "BUTTON") {
        let index = target.getAttribute('index');
        console.log(`我是第${+index+1}个按钮~`);
    }
}; 
```

## 短路语句

```js
A || B  A的值是真 返回A的值 否则返回B的值
A && B  A的值是真 返回B的值 否则返回A的值
如果同时存在  &&高于||
```

## This 

```js
1. this 函数的执行主体 和执行上下文不是一个概念
2. 全局的this 是 window 我们研究中的都是函数中的this
```

### this 的执行规律

```js
1. 给当前元素的某个事件行为绑定方法 事件触发 执行对应的方法 方法中的this 是当前事件本身
```

```js
document.body.click = function () { // this-> body }
// IE 6/7/8 基于 attachEvent 绑定的不是this 是 window
```

```js
2. 函数执行 首先看函数名称之前 是否有 点 有点 点前面是谁 this 就是谁 如果没有 点  this 就是window(严格模式下 没有 点 this 是 undefined)
```

```js
3. 自调用函数/回调函数 中的this 一般都是window 或者 undefined h
```

```js
4. 构造函数中的this 是当前类的实例
5. 箭头函数中没有自己的this 用到的this 都是上下文中的this
6. 基于call / apply / bind 可以强制改变this指向
```

## arguments 形参映射机制

```js
// EC(G)
var = 4
function b (x,y,a) {
    // 形成自己的私有执行上下文 EC(b)
    // 初始化作用域链 <EC(b),EC(G)>
    //初始化this:window
    //初始化 arguments:{0:1,1:2,2:3,length:3}  左侧是真实结构 为了方便看我们携程数组[1,2,3] 这里还会和我们的形参形成映射机制
    // 形参赋值 x =1 y =2 a =3
    //变量提升
    console.log(a) // 3
    arguments[2] = 10
    console.log(a) //10
}
a = b(1,2,3)
console.log(a)
```

## 模块化 / 单列模式设计模式

```js
1. 在很早以前没有引用类型 比如对象 和 函数的时候 想描述个人信息的时候 就需要一个变量一个变量的去定义 这个时候 就会造成全局变量的冲突
```

```js
//比如 我们描述 欧阳花的个人信息
let name = "欧阳花" let age = 21 let sex = '男'
//还想描述 吴家乐的个人信息
let name = '吴家乐' let age = 25 let sex = '女'
//以上我们看到 变量就冲突了
```

```js
2. 所以我们开始用闭包的方式 去描述 因为 闭包里面的变量都是私有变量 不会跟外部产生冲突
```

```js
//闭包的方式去描述
(function(){
    let name = "欧阳花" 
    let age = 21 
    let sex = '男'
})()

(function(){
    let name = '吴家乐' 
    let age = 25 
    let sex = '女'
})()
```

```JS
3. 但是以上 我们如果要在吴家乐那的作用域下 用到 欧阳花里面的变量  只能添加到window上  这种方式 如果变量不是很多还好 
```

```js
// 真实业务开发 B 里面可能要用到 A 的方法 就需要把A的方法暴漏到windows上去
A
(function(){
    let set = 0
    function fn(){}
    function query () {}
    window.query = query
})()

B   里面要用到A 里面的query方法
(function(){
    let set = 0
    window.query()
})()
```

```js
//所以这里 我们就用暴漏对象的方法 把要使用的方法 return 出去 这种方式就叫单例模式
let AModule = (function(){
    let set = 0
    function fn(){}
    function query () {}
   	return {
        query,
        set
    }
})()
// B 模块
(function(){
    let set = 0
    AModule.query()
})()
```

```js
4. 在我们自己编写类库/插件/UI组件/框架的时候 为了防止全局变量污染 我们需要基于闭包的机制进行 "私有化" 处理
```

```js
(function(){
    function Banner(){}
    //利用暂时性死区 如果一个变量没有声明 用typeof检测 是undefined(浏览器可以typeof 可以检测到window 是 'object') 我们利用这个特点可以区分 是浏览器执行js 还是node执行js
    if(typeof window !=='undefined'){
         window.Banner = Banner
    }
    //如果是CommonJS / ES6Module 就会检测到下面两个东西
   	if(typeof module !== 'undefined' && typeof module.exports !== 'undefined'){
	module.exports = Banner
    }
})()
```

## 惰性函数

```js
1. 能执行一次 绝对不会执行第二次 
```

```js
// 我们在获取元素样式的时候 用到的API 有 getComputedStyle 和 currentStyle(这个方法在IE6-8)
function getCss(elemnt,attr){
    if(window.getComputedStyle){
        return window.getComputedStyle(elemnt)[attr]
    }
    return elemnt.currentStyle[attr]
}
//然后我们开始获取元素的样式
console.log(getCss(document.body,'width'))
console.log(getCss(document.body,'padding'))
console.log(getCss(document.body,'margin'))
//总结 这样好么 因为我们每执行一次函数 都需要处理兼容性问题 其实没必要 因为在第一检测时候就已经知道兼容情况了 
```

```js
function getCss(elemnt,attr){
    if(window.getComputedStyle){
        //走到判断 就可以判断我们是哪个浏览器的兼容了 然后改变getCss的指针
        getCss = function (elemnt,attr) {
            return window.getComputedStyle(elemnt)[attr]
        }
    }else{
        getCss = function(elemnt,attr){
            return elemnt.currentStyle[attr]
        }
    }
   // 改变之后 要保证我们的第一个函数要执行一次 拿到结果 
   return getCss(element,attr) 
}
//第一次执行函数
console.log(getCss(document.body,'width'))、
// 第二次走的时候 就直接走到 我们改变指针的那个函数了 
console.log(getCss(document.body,'padding'))
console.log(getCss(document.body,'margin'))
//以上我们 再次执行的是时候 是重构后的小函数 告别了 兼容校验的操作   只执行一次
```

```js
2. 惰性函数 就是函数重构的问题 第一次执行 会产生闭包 
```

## 柯里化函数

```js
1. 区别于惰性函数  是一个预处理的思想 应用的也是闭包的机制
```

```js
let res = fun(1,2)(3)
console.log(res) //求和结果 为6
//实现以上函数 首先第一函数执行的时候 我们不知道传进来几个参数 第二次也不知道 所以我们用剩余形参去接收
//然后把两个函数的参数 连接在一起 在最总进行求和

function fn (...outerArgs){
    //剩余参数 会把你的实参放在一个数组中 而arguments是一个伪数组
    return function anonymous(...innerArgs){
        let arr = outerArgs.concat(innerArgs)
        // 如果reduce里面 没有传第二个形参 那么total 就是数组中的第一项 item是第二项  然后相加就变成3 然后把3作为total 在和 后面的一项相加
        return arr.reduce((total,item) => {
            return total + item
        },这里还可以传第二个形参)
    }
}
```

```js
2. 第一次执行大函数 形成一个闭包(原因:返回了一个小函数) 把一些信息存储到了闭包中(传递的实参信息或者当前闭包中声明的一些私有变量等信息) 等到后面需要把返回的小函数anonymous执行 遇到一些非自己私有变量 则向其上级上下文中查找
```

## 组合函数

```js
1. 把处理数据的函数像管道一样连接起来 然后让数据传过管道得到 最终的结果
2. 以下 就是我们把每个函数的运行结果 当作形参 传递给了下一个函数 参与了运算
```

```js
const add1 = (x) => x + 1
const mul3 = (x) => x * 3
const div2 = (x) => x / 2
div2(mul3(add1(add1(0)))) // => 3
```

```js
2. 上面的写法可读性明显很差 我们可以构建一个compose函数 它接收任意多个函数(而这些函数都只能接收一个参数) 然后compose 返回也是一个函数 

const operate = compose(div2,mul3,add1,add1)
operate(0)   相当于 div2(mul3(add1(add1(0))))
operate(2)   相当于 div2(mul3(add1(add1(2))))
```

```js
function compose(...func){
    return function operate(x){
        //如果你一个数据处理函数也没有传进来  那么 就直接返回你的参数
        if(func.length === 0) return x
        //如果你只传进来一个事件处理函数 那么 我们就执行
        if(func.length === 1) return func[0](x)
        //这里我们要知道 我需要最先执行 func数组里的最后面的函数 然后结果当作参数传给倒数第二个函数里 一次类推 所以这里我们会用到reduce 所以先要把数组反转以下
        let n = 0
        func.reverse()
        return func.reduce((result,item) => {
            n++
            //说明这是第一次 result是add1函数 item是你传进来的第二次个add1函数
            if( n === 1){
            	return item(result(x))
            }
            return item(result)
        })
    }
}


//下面是几种情况
let operate = compose(div2,mul3,add1,add1)
console.log(operate(0))  => 3

//一个数据函数都没有传 就直接返回你的形参
let operate = compose(div2,mul3,add1,add1)
operate(0) => 0  

//如果只传进来一个数据处理函数 就 直接执行
let operate = compose(add1)
operate(0) => 0  
```

## 函数的防抖

```js
1. 对于频繁触发的某个操作 我们只识别一次 
```

```js
function handle() {
    setTimeout(() => {
        console.log('ok')
    },1000)
}
//如果我频繁点击submit这个按钮  他就会一直触发handle这个函数 一直输出OK  如果我们控制让它在300MS 无论你点几次 只触发一次
submit.onclick = handle
```

```js
2. 在当前点击完成之后 我们等wait这么长的时间 看是否还会触发第二次 如果没有触发第二次 属于频繁操作 我们直接执行想要执行的函数func 如果触发了第二次 则以前的不算 从当前这次再开始等待
```

```js
// func 就是你要点击执行的那个函数 wait 就是我们控制在多少时间只内 只执行一次 inmmediate 就是我们让func这个函数 执行 你第一次触发 还是最后一次触发
/*
 * @params 
 * func[function] 最后执行的函数
 * wait[number] 频繁设定的界限
 * inmmediate 默认多次操作 我们识别的是最后一次 但是inmmediate =true 让其识别第一次
 * @return 可以被调用执行的函数 
 */
function debounce (func,wait = 300, inmmediate =false){
    //为什么return 因我们 submit.onclick = function (e) {} 也是执行一个匿名函数
    // 这里 我们可能还有事件对象 e 还有 事件源 this 也需要改变一下指向
    let timer = null //主要是为了清除定时器用
    return function anonymous(...params){
        //我在第一次点击的时候 先清除一下定时器 因为第一没有 所以函数接着往下走
        //第二次的时候 我们清除了之后 定时器函数里面就不执行了 然后又重新开启了一个定时器 把上一次的取消了
        clearTimeout(timer)
        timer = setTimeout(() => {
            //执行你传进来的函数 并且把this的指向指向你的事件源 并且把事件对象传进去
            func.call(this,...params)
        },wait)
    }
}
// 以上 就触发 了最后一次 基本的防抖 就已经实现了
submit.onclick = function () {
    
}
```

```js
// 下面 我们要根据 inmmediate 来控制 只执行触发的第一次
function debounce (func,wait = 300, inmmediate =false){
    let timer = null 
    return function anonymous(...params){
        let now = inmmediate  &&  !timer
        clearTimeout(timer)
        //我第一次进来 还是跟以前一样 设置一个定时器
        timer = setTimeout(() => {
            //3. 手动让定时器回归到初始状态
            timer = null
          	//2. 所以这里也要看看 如果是让我第一次执行 那我定时器里面的就都不执行了
            !inmmediate?func.call(this,...params) : null
        },wait)
        //1. 看看你是否让我立即执行 如果是 我就立即执行 但是同时你等了wait以后 定时器里面的也执行了
        now?func.call(this,...params):null
    }
}
// 以上 就触发 了最后一次 基本的防抖 就已经实现了
submit.onclick = function () {
    
}
```

## 函数的节流

```js
1. 让函数 在一定时间内 执行相应的次数
```

```js
function handle(){
    console.log('ok')
}
// 我们每一次的浏览器滚动过程中 都会触发上面那个函数 频率非常大 浏览器有最快反应时间(5~6ms 13-17ms) z只要反应过来了 就会触发函数
window.onscroll = handle
```

```js
2. 需要知道 我上一次触发的时间 到我这次的时间 小于我的频率时间 如果小于就不执行函数
```



```js
// 每300ms触发一次
/*
 * @params
 * func[function]: 最后要触发执行的函数
 * wait[number]: 触发的频率
 * @return 可以被调用的执行函数
*/
function throttle (func,wait = 300){
    let timer = null
        previous = 0   //记录上一次操作的时间
    return function anonymous(...params){
        let now = new Date() //记录当前函数执行的时间
            remaining = wait - (now - previous) //记录还差多就达到我们一次触发的频率
    	if(remaining <= 0){
            clearTimeout(timer)
            timer = null
            //等于我们的上一次触发时间
            previous = now
            //如果这个小于0 就说明我们已经过了间隔时间 可以触发第二次了
            func.call(this,...params)
        }else if(!timer){
            // 如果你第二次点击发现没有设置定时器我才设置 如果设置了我就不设置了 因为你第二次进来的时候发现我等的那个函数还没执行 所以我就不用设置定时器 只有你没有 我才设置
            // 这里就说明 我们还在我们频率时间内点击了第二次 所以不能触发 我们要等
        	timer = setTimerout(() => {
                timer = null
                previous = new Date()
                func.call(this,...params)
            },remaining)
        }
    }
}

window.onscroll = throttle(handle)
```


---
title: 面向对象
date: 2019-03-28
updated: 2019-06-03
tags: JavaScript 
categories: JS高级
keywords: JS高级
description: JS高级
top_img:
comments: false
cover:
toc:
toc_number:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---

## 编程思想

```js
1. OOP 面向对象  js  java php python 
2. POP 面向过程  c语言 
```

## 面向对象的概念

```js
1. 我们js  所有的东西都可以理解为一个类
2. 比如我们的对象 数组 它上面所有的方法 都是从上面继承下来的
```

```JS
「数据类型类：我们见到的数据值都是所属类的一个实例」
  + Number
  + String
  + Boolean
  + Symbol
  + BigInt
  + Object
    + Object
    + Array
    + RegExp
    + Date
    + ...
  + Function

「DOM对象/节点或元素集合/样式对象或者集合等」
  + HTMLDivElement / HTMLAnchorElement / HTMLUListElement ... 每一种元素对象都有一个自己所属的类
  + HTMLElement / XMLElement ...
  + Element / Text / Document...
  + Node 节点类
  + EventTarget
  + HTMLCollection / NodeList  ...
  + CSSStyleDeclaration
  + ......

---------------
学习JS基础知识，尤其是API层面的
  + 类.prototype：存放的是给当前类的实例调用的公共属性方法
  + 类.xxx：把其当作对象设定的静态私有属性方法
  + ...

document.getElementById('xxx')
   + 获取上下文只能是document?
   + getElementById是在Document类原型上提供的方法，只有Document它的实例才可以调用(document是它的实例)

[context].getElementsByTagName('*')
   + Element类的原型上提供getElementsByTagName方法
   + 每一个元素标签都是Element类的实例
   + Document的原型上也有这个方法，所以document也可以用
   + ...
```

## 自定义类

```js
1. 上面的那些和方法 都是自己去写的类 也就是js 已经你写好的
2. 但是除了以上那些 还远远不够 所以 我们自己就又了自定义类 new class
```

```js
//普通函数执行
function sum (x,y){
    let total = x + y
    this.total = total
    return total
}
let res = sum(10,20)
console.log(res) //输出30
```

![](new.png)

```js
// 当我们加了new 之后 执行的方式就不一样了
function sum (x,y){
    let total = x + y
    this.total = total
    return total
}
let res = new sum(10,20)
console.log(res) //  {total:30} 执行结果

```

### 带 new 的函数执行都干了什么

```js
1. new 的函数执行  首先会和普通函数一样 形成上下文EC(XXX) AO(xxx) 初始化作用域链 形参赋值 变量提升 等等
2. new的函数执行 在代码执行之前 私有上下文之前 会创建一个空对象
3. 然后初始化this的时候  就会让我们的this 指向我们创建的对象
4. 后期在代码执行过程中 如果遇到this.xxx 都是给我们上面创建的那个实例对象创建私有的属性和方法
5. 如果没有些 return 默认是把我们的创建的对象返回 如果自己写了 return  自己返回的是基本类型值 写也没用 还是返回我们上面创建的那个对象 如果返回的是引用类型值 返回的是你自己写的引用类型
6. new Fn 也相当于把函数执行了 不带列表的 new 最后 Fn 都一定会执行 而且都会创造这个类的实例 区别 是否传递实参  以及运算优先级不一样
7. 所有的类都是一个函数数据类型值 内置类/自定义类
8. 每一次new 类创造的实例都是 独立的实例对象 这种模式在js中叫做 构造函数模式
```

![](new-1.png)

## 面向对象 原型prototype 和 原型链__proto__

```js
1. 每一个类(函数) 都具备 prototype(隐式原型) 并且属性值是一个对象
2. prototype 对象上天生具备一个属性 constructor 指向类本身
3. 每一个对象(普通对象、prototype、实例、函数等)都具备__proto__(显式原型) 属性值是当前实例所属的原型
4. 所有的类都是函数数据类型(包括内置类) 所有的函数都天生自带一个属性 prototype 属性值默认是一个对象数据类型 其存储的是 供实例能调用的公共属性和方法 
5. 所有的对象数据类型值也天生自带一个属性__proto__原型链 它的属性值:当前类的原型prototype 实例.__proto__ = 类.prototype
6. 如果我们调取了实例中的一个方法 它先看自己的实例上有没有 如果没有就去原型上找  这个就是原型链查找机制
```

![](prototype.png)

```js
//总结
1. 首先我们每个函数上面都有一个 prototype(原型)属性 是一个对象 对象里面有我们的constructor 指向我们的函数本身
2. 当new 执行函数的时候 初始化的this的时候 我们会单独开辟一块空间 创建一个实例对象 只要是对象就会有一个属性__proto__
3. 每个对象上面 都有 一个__proto__ (原型链)也是一个对象 如果这个函数是new 执行的 那么 __proto__指向的就是我们函数的 prototype
4. 也就是说 实例对象(new 执行函数的时候初始化this出来的那个对象).__proto__ =  类(也就是我们的构造函数).prototype
5. 我们函数的 prototype(原型) 也是一个对象 那么它也有一个__proto__ 指向应该是构造我们的prototype的函数 那么这个函数就是 new Object()
6. 所以 当我们一个类上的方法没有的时候 它就会去我们的原型上找 如果没有 就顺着原型链 一步一步的向上查找 最终找到我们的 Object 函数 这就是 原型链查找机制
```

## 原型重定向

```js
1. 原型重定向 就是把 prototype 的指针指向一个新的对象
2. 原型为啥要重定向 为了方便给原型上扩充属性和方法
3. 原型重定向 带来的问题是 新定向的原型对象上 没有constructor属性 结构不完整 我们浏览器默认生成的原型对象因为缺少引用 会被释放掉 可能导致原始加入的属性和方法丢失掉
```

```js
function Fn (){
    this.x = 100
    this.y = 200
}
// 原始的原型对象
Fn.prototype.getX = function(){}
//这个时候 就相当于给我们的原型重定向了 那么我们之前在prototype上的getX 这个方法也没有了 constructor也没有了 这种重定向 可以批量添加属性和方法
Fn.prototype = {
    //如果原始的原型对象不存在其他的属性和方法 我们只需要手动添加constructor 指向我们的类
    constructor:Fn
    getY:function(){},
    getX:function(){},
    getZ:function(){},
}
//如果我们的原型对象上有别的属性 我们就需要合并进来
/*
 *    Fn.prototype = Object.assgin(Fn.prototype,{
 *			getY:function(){},
 *   		getX:function(){},
 *  		getZ:function(){},
 *	  })
 *
 */
let f1 = new Fn
```

![](prototype1.png)

## 原型重写 new

```js
1. 我们自己来实现一个_new函数 
2. 这里就需要知道new的时候 都干了什么 
3. 首先 new 函数执行 和普通函数的执行一样  形成私有上下文 初始作用域链 形参赋值 变量提升 代码执行
4.  创建了一个空对象 this 指向了它 对象.__proto__ = Dog.prototype 
5. 把this 指向 指向这个我们创建的空对象 如果没有 return 或者返回的是基本类型值  则返回都是实例对象 否则返回我们自己定义的对象
```

```js
function Dog(name,age){
    this.name = name
}
Dog.prototype.bark = function () {console.log('wangwang')}
Dog.prototype.sanName = function () {console.log('my name is' + this.name)}

function _new (func,...params){
    //1. 首先我们要创建一个实例对象
    let obj = {}
    obj.__proto__ = func.prototype
    
    //2. 把类当作普通函数执行 并且让this 指向我们的实例对象
    let res = func.call(obj,...params)
    
    //3. 根据返回结果 决定返回啥
    if(res !== null && (typeof res === 'object' || typeof res === 'function')) return res
    return obj
}
let sanmao = _new(Dog,'dahuang',23)
sanmao.bark()
samao.sayName()
// IE 我们使用不了__proto__ 所以就要用到下面的方法
// 创建了一个空对象 并且把对象A作为它的原型 空对象.__proto__ = 对象A
Object.create(obj)
```

## 基于内置类原型扩充方法

```js
1. 我们知道内置类 比如 Array Object 都是函数数据类型 就会有一个自己所属的堆内存 但是里面的代码我们看不到 就会有一个 native code 
2. 每一个函数 都会自带一个属性 叫 prototype 属性值是一个对象 自带一个属性constructor 指向自己构造函数本身 
3. 像内置类的原型上扩充方法 最好设置私有前缀 而且扩充方法里面的this 就是我们的当前实例
4. 必须要保证 this 是我们当前要操作的实例  
```

```js
// 我们用 数组去重举例 
//我们arr 都是我们 Array的实例  所以我们可以调用Array.prototype上的方法 
let arr = [1,2,3,3,1,8] 
Array.prototype.myUnique = function () {
    //这里面的this 就是我们实例本身  所以首先我们要保证 this 是个数组
    if(!Array.isArray(this)) throw new TypeError('不是一个数组')
    return Array.from(new Set(this))
}
arr.myUnique() //直接就可以去重
```

```js
// 我们现在 实现一个加减 的方法
let n = 10
let m = n.plus(10).minus(5)
console.log(m) // (10+10-5) 15

//如果我们基于原型上扩充方法
Number.prototype.plus = function(num) {
    //这里面我们输出this 发现并不是10 而是引用类型 Number(10) typeof this => 'object'
    //这里所有的this 都不是基础类型的值 都是引用类型的值
    // 如果我们想变成基础类型值 我们需要用call apply bind 改变this 指向 变成基础类型值
    console.log(this) // Number(10)
    // 我们知道 上面的就是个对象 对象 相加 就会变成 '[obejct object]10'
    // 但是我们这个方法是有原始值 会先调用valueOf获取原始值(number/string/boolean/Date)
    // 如果有原始值 就获取到结果即可并且参与到运算 如果没有就转换称字符串
    return this + num
}

Number.prototype.minus = function(num) {
    return this - num
}
```

```js
//基于以上的总结
1. JS创建一个值有两种方法 一种是字面量 一种是构造函数
let n = 10 //字面量
let n = new Number(10) // number(10)
2.  上面不论哪种方法 创建出来的都是一个实例
3.  基础数据类型 上面的那辆创建方式 输出结果是不一样的 字面量 就是 10  构造函数创造出来的就是引用类型 Number(10)
4. 我们字面量方式创造的值 在调用方法的时候 会默认 把字面量的方式 变成引用类型值 在去原型上调方法
```

## 函数的三种角色

```js
1. 我们要知道 所有的函数 都是也都是 Function 的内置类 置换出来的
2. 但是函数的内置类的原型 prototype 不是一个对象 是一个匿名空函数 但是操作上和其他类的原型一摸一样 没有啥却别 
3. 函数的三种角色普通函数执行 闭包作用域
   构造函数执行 new 类和实例
   普通对象 键值对
4. 这三种角色之间没有必然的联系
5. 这里我们知道 我们的内置类Array Object Number 这些也都是函数 那么函数也是一个对象 所以他们作为普函数来说 都会有__proto__ 都会指向我们 Function 的prototype 
```

![](function.png)

```js
//实例
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}
Foo.getName = function () {
    console.log(2);
};
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
}
// 首先 函数记得有三种角色 第一种是 当作普通函数执行 第二种是 new 执行 第三种是 作为对象
// 这里就相当于 我们把Foo当作一个对象 访问了它的getName属性执行 所所以输出结果是 2
Foo.getName(); // 2
// 这里就是执行全局的函数getName() 全局我们可以看到 第一次函数是5 但是 后来 有重新把函数赋值了 所以输出 是4
getName(); // 4
// 这里是当作普通函数执行 普通函数执行return this  这里的this 是window 但是 函数执行的时候 又把全局的getName()重新写了 所以就相当于调window.getName() 是1
Foo().getName(); // 1
//因为全局的函数已经被重新了 所以输出是1
getName(); // 1
// 这就存在优先级的问题 是new 函数执行的优先级搞 还是 成员访问的优先级高
// obj.xxx 访问的优先级 是 19 new Fn() 带参数 是19  new Fn 是18 如果优先级相同那么就从左向右一次执行
// 所以我们要先执行Foo.getName() 就相当于 执行了 new function(){console.log(2)} new的时候函数也会执行 所以 输出的是2
new Foo.getName(); //2
// 这里 由于两个优先级 都是相同的 所以 从左向右一次执行  所以这里new Foo()执行 创建了实例对象 this 指向了这个实例对象 那么这个实例对象上没有getName() 就要像原型上找 也就是Foo.prototype.getName() //所以输出结果是3
new Foo().getName(); //3 
//这里从上面一样 只不过最后当普通函数执行了 输出结果也是3
new new Foo().getName(); //3
```

![](function2.png)

## THIS种的五种情况

```js
1.  给当前元素的某个事件行为 绑定方法 当事件行为触发 方法执行 方法种的this 一般都是 当前操作元素 排除IE6~8中 基于 attachEvent进行的DOM2事件绑定 方法中的 this 是 window
```

```js
document.body.onclick = function () { console.log(this) } //输出是body
document.body.addEventListenner('click',function(){console.log(this)}) //输出是body
```

```js
2. 函数执行(看函数前面是否右点) 点前面是谁 this 就是谁 没有点 this 是window 严格模式下 是undefined 匿名函数(自调用函数/回调函数) 一般this 就是window
```

```js
const fun = function () { console.log(this) }
let obj = {
    name:'obj',
    fn:fun
}
fun() //输出this 是 window  严格模式下 use strict undefined
obj.fn() // this 是obj
(obj.fn)() //同上
//括号表达式  括号里面有多项的情况下 只取最后一项 
(10,20,obj.fn)() // this 是window
//自调用函数
(function(){console.log(this)})() // window
//数组的回调函数
[1,2].sort(() => {console.log(this)}) // window
// forEach
[1,2,3].forEach((item)=>console.log(this),obj) //这里forEach处理了改变了this指向 就是obj 
```

```js
3. 构造函数 new 执行 函数体中的this 是当前的实例
```

```js
function Fn(){
    this.x = 100
}
//普通函数执行 this 是window
Fn()
// new 执行 this 是实例本身 也就是f
const f  = new Fn()
Fn.prototype.say = function () { console.log(this.x) }
// 本身私有属性上没有这个方法 就去原型prototype去找 由于是f的实例调取的 所以this 是f 
f.say()
```

```js
4. 箭头函数中 或者 基于{} 形成的块级上下文 里面没有 this  如果 代码中有this 也不是函数自己的 而是 自己所在的上下文中的
```

```js
let obj = {
    name:'obj',
    fn(){
        setTimeout(function(){
            this.name = 'xxx'
        },1000)
    }
}
obj.fn()  //这里面的定时器 this 是window 

// 如果是箭头函数 他就会去找上一层的this 也就是我们函数定义的上下文 上一层的this 取决于谁调用

let obj = {
    name:'obj',
    fn(){
        //或者我们也可以 把this 先存期来 let _that = this
        setTimeout(() => {
            //_that.name = xxx
        	this.name = 'xxx'
        },1000)
    }
}
```

```JS
5. 我们可以基于function.prototype 上的call / apply /bind 去改变this 指向 但是对于箭头函数无用
```

```JS
const fn = function fn (){
    console.log(this)
}
window.name = 'xxx'
let obj = {
    name:'obj',
    fn:fn
}
fn()  // 输出 是 window.name
obj.fn() // 输出是 obj.name
// 如果 obj 里面没有fn 属性  但是我们还想让fn的this 指向 obj 那么就要用到call appply bind
fn.call(obj,这里面还可以传参)
```

```js
// call 的执行逻辑
fn.call(obj,10,20)
首先 fn 基于原型链__proto__ 找到 Function.prototype.call 方法 并且把call 方法执行
call 方法中的this 就是 当前操作的实例fn 传递给call 方法的第一个实参 是未来改变fn中的this 指向 剩余参数 都是未来要一次传递给fn的参数信息
call 方法执行的过程中 这样处理 把fn[call中的this]执行 让fn 中的this 指向obj 并且把参数也传递进去
call 如果第一个参数 如果不传 或者传 null / undefined  在js 非严格模式下 最后fn 中的this 都是window (严格模式下 不传this 是undefined) fn.call(10,20) //fn this -> 10
// apply 
和call 一样 只不过传参的时候 后面的 要以数组的形式 fn.apply(obj,[10,20])
// bind 是预先处理 执行bind 先把函数中需要改变的this 等存储起来 但是此时函数不会被执行 执行bind的时候 会返回一个匿名函数 当后期执行匿名函数的死后 再去把之前需要执行的函数执行 并且改变this 为预设的值
```

```js
// 定时器中的call
let obj = {
    name:'obj.name'
}
window.name = 'window.name'
function fn(){
    console.log(this.name)
}
// 这样是不行的  我们call 方法 在改变this 的时候 是立即执行的 这样是不可以的1000之后就不在执行了
setTimeout(fn.call(obj),1000)
//解决方法   我们把它写在一个函数里
setTiomeout(function(){
    fn.call(obj)
},1000)
//解决方法 用bind 因为bind 是返回一个柯里化函数
setTimeout(fn.bind(obj),1000)
```

## 手写call / apply / bind 源码

### 手写 bind 

```js
function fn (x,y) {
    this.total = x + y
}
let obj = {
    name:'obj的名字'
}
//我们普通的点击事件 就要执行一个函数 里面还有事件对象的参数
document.body.onclick = function (e) {
    //这里面的this是我们的body
}
// 所以 我们用 bind 的时候 首先也要返回一个函数 并且要传递事件对象 并且要改变this 指向
documnet.body.onclick = fn.myBind(obj,10,20)

Function.prototype.myBind = function (context,...params) {
    //首先这里面的this 是我们的fn 函数 因为是 fn 调取的myBind 函数 
    //context -> 你传进来的obj对象
    //params -> 是 你传进来的是10 20
    // 这里面我们要retrun 一个匿名函数 anonymous 也就是点击body的时候要执行的匿名函数
    let _that = this
    return function anonymous (...arg) {
        //首先这里面的this 因为是body调取的这个函数 所以 this 是body
        //2. 所以就需要我们拿到外面缓存的that
        _that.call(obj,...params.concat(arg))
    }
}
//当然 这里我们也可以写成箭头函数的形式 这样就不用缓存this 了 它会去它所所以的上下文中的上层去找this
Function.prototype.myBind = function (context,...params) {
    return (...arg) => {
        //首先这里面的this 因为是body调取的这个函数 所以 this 是body
        //2. 所以就需要我们拿到外面缓存的that
        _that.call(obj,...params.concat(arg))
    }
}
```

### 手写call

```js
// call 和 apply  是立即执行 不会像bind 一样 赶回一个匿名函数
Function.prototype.myCall = function (context,...params){
    //context -> 就是你传进来的obj
    // ...params 就是你传进来的参数
    // 这里面的this 就是你的fn 函数 因为是fn 调用的 myCall
    // 首先 我们要让我们fn 和我们的obj 产生关系 比如 obj.fn = fn 这样再掉用fn的时候 this 就是我们的obj了
    //其次 我们在obj 上添加了一个fn 的属性 需要注意两点 第一个 fn是你自己后添加的所以用完需要删除 第二 如果人家obj上原本就有一个fn的属性 你就把人家的覆盖了 所以我们要用Symbol来确定唯一
    
    //如果你传进来的是个undefined 或者null 我们都要把this 指向window 这里 在两个等于 == undfined 和 null 是相等 如果是三个等于就不等了
    context == null ? context = window : null
    // 如果你的context 不是一个引用类型的值 而是基础类型的值 比如数字10 我们就需要先把它处理成 引用类型值 比如传进来的是个10 我们就处理称 Number(10) 这样就可以添加this
    
    // 如果你的类型不是object 和 function 就说明 你是基础类型值 那么我们就需要处理 如果是我们就什么也不干
    !/^(object|function)$/i.test(typeof context) ? context = object(context) : null
    let result
        //这里我们需要创建一个唯一的属性值 来避免你原来obj上的属性值冲突
    	key = Symbol('key')
    //让fn 函数 和我们的obj 家里关系
    context[key] = this
    result =  context[key](...params)
    // 用完之后 把我们新增的删除
    delete context[key]
    // 如果有返回值 就返回 
    return result
}
```

## js中的继承

```js
1. JS 本身是基于面向对象开发的 编程语言 我们学习 就是学习的它的类
2. 那么类 就具备 封装 继承 多态
3. 封装 类也是一个函数 把实现一个功能的代码进行封装 实现 低耦合高内聚
4. 多态 又分为 重写 和 重载
   重写  子类 可以重写 父类上的方法(伴随这继承)
   重载  相同的方法 由于参数或者返回值不同 具备了不同的功能(js 不具备严格意义上的重载)
5. 子类可以继承父类中的方法
```

### 原型继承

```js
1. 原型继承 其实就是让 子类的原型 prototype 指向 父类的实例 
2. 把实例上的方法 和属性 都变成子类共有的
3. 父类中私有和共有的属性方法最后都变成子类实例共有的 但是和其他语言不同的是 原型继承并不会把父类的属性方法 拷贝 给子类 而是让子类实例基于__proto__ 原型链找到自己定义的属性和方法
```

```js
function Parent() { this.x = 100 }
Parent.prototype.getX = function () { return this.x }
function Child () { this.y = 200 }
//现在CHild 想用 Parent的方法 所以我们就让 Child 的 原型 prototype = new Parent 
Child.prototype = new Parent
Child.prototype.getY = function () { return this.y }
let c1 = new Child
```

![](jicheng.bmp)

### call继承

```js
1. 我们刚刚看到原型继承  父类 私有的 和父类公有的 属性和方法 都变成子类实列公有的了 这样不是我们期待的
2. 所以有了call 继承 但是 只是把父类私有的 变成子类公有的 但是并没有 把父类公有的 变成子类公有的
```

```js
function Parent () { this.x = 100 }
Parent.prototype.getX = function () { return this.x }
function Child () { 
    //这里面的this 就是 Child 我们需要把Parent 里面的this 指向成我们 Child 所以就用了call
    Parent.call(this)
    this.y = 200 
}
//以上 我们就把Paret里面的 x 变成 我们 Child 里面 的 y 了 这样就把 我们的 Parent里的y 变成我们Child 里私有的了 但是Parent 里面的 公有的方法 却没有继承过来
```

### 寄生组合式继承

```js
1. 就是 把我们的原型继承 和我们的call 继承 组合其来
2. 这样的好处 就是 把父类私有的 变成 子类 私有的 父类公共的 变成 子类中公有的
```

```js
function Parent() { this.x = 100 }
Parent.prototype.getX = function () { return this.x }
function Child () { this.y = 200 }
//这里就是 把我们的基于我们原型链上去 查找 我们的 这样我们的父类的私有属性 就 就带入不到 我们的子类里面去了
Child.prototype.__proto__ = Parent.prototype 
Child.prototype.getY = function () { return this.y }
let c1 = new Child
```

```js
// 但是以上的方法 在IE中这个方法并不可用 所以我们需要是用Object.create()
// Object.create()  就是创建一个空对象 并且 把这个空对象的原型链 __proto__ 指向 我们的传进来的 这个对象

function Parent() { this.x = 100 }
Parent.prototype.getX = function () { return this.x }
function Child () { this.y = 200 }
//直接 让我们一个 prototype = {} 这个 对象里面__proto__ 指向了我们的 Parent.prototype
Child.prototype = Object.create(Parent.prototype) 
Child.prototype.constructor = Child
Child.prototype.getY = function () { return this.y }
let c1 = new Child
```

```js
//实例
function C1() { if (name){
    this.name = name
}}
function C2() { this.name = name}
function C3() { this.name = name || 'join'}
C1.prototype.name = 'Tom'
C2.prototype.name = 'Tom'
C3.prototype.name = 'Tom'
new C1().name //有条件判断 没有走if 所以name 属性就要去自己原型上找 是Tom
new C2().name //name 作为形参 没有传 所以值是undefined 
new C3().name // name 没传 但是走了或者的逻辑 所以 值是 join
```

```js
//示例 
function Fn() {
    let a = 1
    this.a = a
}
Fn.prototype.say = function () {
    this.a = 2
}
//这里我们Fn函数的原型prototype 就指向一个对象 里面有 constructor:Fn 这里 我们重新new Fn就相当于把 Fn.prototype指向了 new出来的fn的实例对象 但是Fn的原来的原型并没有销毁还在内存中  实例对象有一个__proto__ 它指向了Fn的原型
Fn.prototype = new Fn
// new Fn 的实例
let f1 = new Fn
Fn.prototype.b = function () { this.a = 3}
console.log(f1.a) // f1上的a 是1 因为 new 的时候也当普通函数执行了
console.log(f1.prototype) //undefined f1的实例上没有prototype这个属性 只有在类的函数上才有
console.log(f1.b) //是个函数
console.log(f1.hasOwnProperty('b'))// false  这个是判断b 是不是 f1的私有属性 b函数并没在私有上 而是在 公有上 所以是false
console.log( 'b' in f1) // true  这个不一样 只要私有 原型上都能找到啊 
console.log(f1.constructor == fn) // true  会从原型链上一点一点向上找
```

![](yuanxing.bmp)

```js
//实例
let obj = {
    2:3
    3:4
    length:2
    push:Array.prototype.push
}
obj.push(1)
obj.push(2)
console.log(obj)
//以上我们要了解一下数组中的push 是怎么实现的
let arr = [10,20]
arr.push(30)
Array.prototype.push = function (val) {
    //这里面的this 是arr 
    //这里面的代码 执行如下 相当于把代码的最后一位等于你添加进来的值
    this[this.length] = val
    // arr[arr.length] = val
    this.length++
}
//我们知道以上的方法执行再来看我们的obj
obj.push(1)
//这里执行的就是我们上面数组里面写的方法
obj.push = function (val) {
    //这里的this 就是obj
    this[this.length] = val
    //obj[obj.length = 2] = 1
    obj[2] = 1
    obj.length++
}
//以上下的步骤都是如此 所以最后输出obj
let obj = {
    2:1
    3:2
    length:4 // 由于每次执行push方法之后 length都会++ 先从2 加加 成3 有从 3 加加到 4
}
```

```js
// 实例
 我们知道 如果 == 两边类型不一样的话 都是转换成字符串 在转换成数字
 那么 比如对象 {} [] 转换成 数字的话 都是调取的原始值
 浏览器底层机制 会预先处理 使用 [Symbol.toPrimitive] 这方法去获取原始值在转换成数字
 可是这个方法如果不存在 就会去调用valueOf方法(基本数据类型值上 比如 number string date)都会有这个方法 如果没有 就会调 toString 去转换为字符串 在把字符串 变换成数字
 // 所以如下提
 let a = ?  // a等于多少的时候  能输出ok
 if(a==1 && a == 2 && a ==3 ){
     console.log('ok')
 }
//所以我们知道 根据以上规则 它肯定回去调[Symbol.toPrimitive] 这个方法 但是 没有所以我们要自己写一个
let a = {
    value:0,
    [Symbol.toPrimitive](hint){
        // 浏览器调取这个方法的时候 会传递一个hint 存储当前对象即将转换什么值
        return ++this.value
    }
}
//这个时候 两个等号比较的时候 如果类型不一样会先转换成数字 基于以上的规律获取原始值 则会调用 Symbol.toPrimitive 这个方法 这个方法是我们写的(因为自己写了) a==1 的时候 会调取一次 value就++了 a==2 还会调取一次 
if( a== 1 && a == 2 && a ==3){
    console.log('ok')
}
//还有第二种写法
let a = [1,2,3]
// 代码逻辑 a.shift 删除 1 然后在转换为字符串 返回的就是1 然后 继续删除2在转换为字符串 也可以走进上面的那个if里面去
a.toString = a.shift
// 方案2 用数据劫持
let i = 0
//看看a 是不是window的一个属性
Object.defineProperty(window,'a',{
    get(){
        return ++i
    }
})
if(a == 1 && a == 2 && a == 3){
    console.log('ok')
}
```

## 数组对象的深克隆/浅克隆

### 浅克隆

```js
1. 浅克隆 就是 把一级对象 拷贝一份 如果对象里面还有引用类型的值 是拷贝不了的
```

```js
let obj = {
    a:100,
    b:[10,20],
}
//浅克隆
let newObj = {...obj}
newObj === obj // 输出 false 因为地址不一样了
newObj.b === obj.b // 输出 true 因为地址没有拷贝过来

//for in 循环拷贝 
for(let key in obj){
    //这里注意 for in 遍历 会把当前对象上可枚举(列举)的属性 就是你能看到的都会拷贝 原型上的也会
    // 但是除了一些内置属性是不可枚举的 比如 数组的length 虽然可以看到 但是 不会被拷贝
    //公有属性 大部分都是不可枚举的 但是自己在内置类原型上扩展的 是可枚举的 也就是可以拷贝
    if(!obj.hasOwnProoerty(key)) break
    newObj[key] = obj[key]
}

for of 循环 只会拷贝 私有的
```

### 深克隆

```js
1. 方案一  都变成字符串 在重新变成对象 这样浏览器会重新开辟全套的内存空间存储信息 比如 JSON.Stringify / JSON.parse
```

```js
// 缺点 值如果是 正则 Symbol('AA') BigInt 函数 日期对象(会变成字符串) 都会拷贝不过来
let obj = {
    a:100,
    b:[10,20,30],
    c:{x:10},
    d:/^\d+s/,  //正则在用JSON 拷贝的时候 会变成{} 空对象
    e:Symbol('AA') // 不会被拷贝 直接没有e这个属性
    f:function(){} // 函数同上
}
```

```js
2. 方案二 自己单独一层一层处理
```

```JS
function cloneDeep (obj) {
    let	type = typeof obj
    if(obj == null) return null
    //如果传递的不是对象类型 就直接返回对应的值
    if(type !== 'object') return obj
    //知道 传进来的是什么类型
    let constructor = obj.constructor
    //如果是正则 或者 日期 对象 constructor 就是你的构造函数 可能是 new RegExp | Date
    if(/^(RegExp|Date)$/i.test(constructor.name)) return new constructor(obj)
    // 这里如果你传进来 是数组 那么 就是 Array 对象 就是 Object 如果是函数 就是 Function 如果是 数字 那么就是 Number
    // 然后我们进创建一个新实例 可能是新数组 也可能是新对象
    let clone = new constructor
    for(let key in obj){
        //只有私有的我们才处理
        if(!obj.hasOwnProperty(key)) break
        clone[key] = cloneDeep(obj[key])
    }
    return clone
}
```

## 数据类型检测

```js
1. typeof  返回结果是一个字符串 字符串包含了对应的数据类型 number string boolean bigint undefined symbol object function 原理是 按照计算机底层存储的二进制来进行检测的 也无法区分 是哪个构造函数 搞出来的实例
typeof null  -> 'object'
2. instancof 并不是用来检测数据类型 是用来检测当前实例是否属于这个类 不支持基本数据类型值
3.constructor 支持基本数里类型值
4.Object.prototype.toString.call 专门用来检测数据类型的 (很强大很暴力的一种版本,基本没有缺陷)
```

### instancof

```js
//instancof 
let arr = []
console.log(arr instanceof Array) //true
console.log(arr instanceof Object) //true 绝对不能证明XX instancof Object 是 true 就是普通对象
console.log(arr instanceof RegExp) //false

// 检测字面量方式的时候 会出错
let n = 10
let m = new Number(10)
console.log(n instanceof Number) // false
console.log(m instanceof Number) // true

// 如果把原型改了 检测的值也会出错
function Person(){}
Person.prototype = Array.prototype
let p1 = new Person
console.log(p1 instanceof Person) //输出为true

// 原理 
arr instancof Array 
//其实相当于调取了 Array 上的一个方法Symbol.hasInstance
Array[Symbol.hasInstance](arr)
// 而我们知道 Array 是 Function 的实例 所以这个方法 在Funcion的 原型上 prototype
arr.__proto__ === Array.prototype => arr instanceof Array
arr.__proto__.__proto__ === Object.prototype => arr instanceof Object
```

```js
//重写 instancof 
// obj是要检测的值
// constructor 检测的 是不是 你传进来的
function instance_of(obj,constructor){
    //参数校验 如果你传进来的 不是引用类型 比如是字面量的10 或这 字符串 null 我就直接false
    if(obj === null || /^(object|function)$/i.test(typeof obj)) return false
    if(typeof constructor !== 'function') throw new Error('类型错误')
    //这一步 就是 obj 的原型连  
    let proto = Object.getPrototypeOf(obj)
    //获取 你传进来的函数的原型 
    let prototype = constructor.prototype
    //开始循环
    while(true){
        // 顺着原型链一层一层向上找 如果找到最后 找到头了 就返回null
        if(proto === null) return false
        // 如果是一个自定义类 我们就返回true
        if(proto === prototype) return true
        //以上都没有的就继续一层一层 向上找
        proto = Object.getPrototypeOf(proto)
    }
}
```



### constructor

```js
// 如果constructor 在不修改的情况下
let arr = []
console.log(arr.constructor === Array) //true
console.log(arr.constructor === Object) //false
console.log(arr.constructor === RegExp) //false
// 而且 也支持 基本数据类型值
let n = 10
n.construtor === Number // true
```

### Object.prototype.toString.call

```js
// 基本上所有类的原型上 都有toString方法 Number String Boolean Array Function RegExp Symbol Date Object
// 这些方法里面 除了 object.prototype.toString  是用来转检测数据类型的 其余都是用来转换为字符串的
({}).toString() // 调取的就是 object.prototype.toString 方法 返回就是它的类型'[object Object]'
document.querySelectorAll('*').toString() //调用的也是object.prototype.toString 方法 返回的是 '[object NodeList]'
//以上的返回结果  后半段的值 取的是 Symbol.toStringTag这个值
'[object [Symbol.toStringTag]]'
//所以我们使用的时候
let arr = []
//使用这个方法 来检测 arr
Object.prototype.toString.call(arr) //输出 [object Array]
```


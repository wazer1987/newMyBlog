---
title: 拖拽
date: 2020-03-28
updated: 2020-06-04
tags: JavaScript
categories: 项目实战
keywords: JavaScript
description: JavaScript 
top_img:
comments: false
cover:
toc:
toc_number:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---

# 拖拽

## 思路

```js
1. 我们现在已知的有 鼠标按下的位置 A 鼠标在移动的时候的位置 B 盒子开始的位置 C1
2. 所以盒子当前的位置 D = B - A + C
3. 拖拽触发的条件 鼠标按住盒子才开始拖拽 鼠标抬起拖拽就算结束
4. 拖拽开始后 鼠标移动盒子才会跟着移动
5. 所以当我们鼠标按下的时候 mousedown 记录 A(鼠标按下的位置) C(盒子开始的位置)
6. 鼠标移动的时候 mousemove 获取 B(鼠标随时移动的位置) 动态计算出D 修改盒子样式 让盒子跟着移动
7. 鼠标抬起 mouseup 取消拖拽
```

![](1.png)

## 鼠标按下

```js
1. 当鼠标按下的时候 我们要记录我们按下的位置 还有 盒子的初始位置 
2. 记录这个位置的时候 我们 要在移动中 也要使用 也就是说 我们在mousemove的时候 也要使用到这个数据 
3. 所以这个时候 我们可以 把这些数据记录在全局上 方便使用 也可以直接挂在到我们的box上 因为 移动事件 也是在我们box上发生的 我们可以通过this 取到
```

```js
//鼠标按下的时候 执行down函数
box.addEventListener('mousedown',down)
const down = function (ev) {
    //1.拿到盒子初始位置 这些信息可能未来会在别的函数中应用
    //所以我们要把它挂在我们盒子的自定义属性上
    let {
        top,
        left
    } = this.getBoundingClientRect()
    //2.把我们拿到的信息 挂在到我们的盒子上
    this.startT = top
    this.startL = left
    //3.鼠标开始位置 也挂在我们的盒子上
    this.startX = ev.clientX
    this.startY = ev.clientY   
}
```

## 鼠标移动

```js
1. 鼠标移动的时候 我们要动态计算 我们盒子移动的距离
2. 这个时候 我们有个顺序 一定是 鼠标按下的时候 才会监听我们的移动事件
3. 所以 鼠标移动的事件 要写在 我们的按下里面
4. 并且 要时刻计算 我们盒子移动的距离 这里 我们已经把我们需要的数据挂在到我们盒子上了
```

```js
const down = function (ev) {
    let {
        top,
        left
    } = this.getBoundingClientRect()
    this.startT = top
    this.startL = left
    this.startX = ev.clientX
    this.startY = ev.clientY   
    //2. 这里注意只有鼠标按下的时候  而这里面this 就是当前的盒子 才能开始移动
    this.addEventListener('mousemove',move)
}
//2.鼠标移动拖拽中
const move = function(ev){
    // 动态算出来盒子应该移动的位置 
    let curL = ev.clientX - this.startX + this.startL
        curT = ev.clientY - this.startY + this.startT
    // 然后设置我们的盒子移动的距离
    this.style.left = curL + 'px'
    this.style.top = curT + 'px'
}
```

## 鼠标抬起

```js
1. 鼠标抬起 我们要做的事情 就是要解绑 我们移动事件 和按下事件
2. 这里也是用this 即可 因为 事件源都是我们的盒子
```

```js
const down = function (ev) {
    let {
        top,
        left
    } = this.getBoundingClientRect()
    this.startT = top
    this.startL = left
    this.startX = ev.clientX
    this.startY = ev.clientY   
    this.addEventListener('mousemove',move)
    //1. 鼠标抬起的时候我们要移除上面的事件
    this.addEventListener('mouseup',up)
}
const move = function(ev){
    let curL = ev.clientX - this.startX + this.startL
        curT = ev.clientY - this.startY + this.startT
    this.style.left = curL + 'px'
    this.style.top = curT + 'px'
}
const up = function() {
  //这里面要做的事情 就是 解绑我们的事件
    this.removeEventListener('mousemove',move)
    this.removeEventListener('mouseup',up)
}
```

## 处理边界

```js
1. 我们需要找到最大边界值
2. 这里我们按照一屏去计算 一屏的安全值 我们通过 document.documentElement 去获取
```

```js
let box = document.getElementById('box')
    //4. 拿到了一屏幕的高度和宽度
    HTML = document.documentElement
    //4. 设置了边界
    minL = 0
    minT = 0
    maxL = HTML.clientWidth - box.offsetWidth
    maxT = HTML.clientHeight - box.offsetHeight
```

```js
const move = function(ev){
    // 动态算出来盒子应该移动的位置 
    let curL = ev.clientX - this.startX + this.startL
        curT = ev.clientY - this.startY + this.startT
    //边界判断
    curL = curL < minL ? minL : (curL > maxL?maxL:curL)
    curT = curT < minT ? minT : (curT > maxT?maxT:curT)

    // 然后设置我们的盒子移动的距离
    this.style.left = curL + 'px'
    this.style.top = curT + 'px'
}
```

## 鼠标焦点丢失

```js
1. 首先 我们的拖拽事件 是在指针在盒子上按下的时候 才会执行
2. 鼠标在盒子上按下了 我们能监听到移动事件
3. 如果我在移动的过程 移动过快 而此时 鼠标的指针 已经不在盒子的范围内了 当我们鼠标在移动的的时候 就不管用了
4. 而此时 我们在抬起鼠标的时候  由于我们的鼠标抬起 也是在鼠标按下的时候 才会执行里面的事件 而此时 我们的鼠标已经不在盒子里了 就不会执行我们的抬起事件
5. 这个问题就叫做光标丢失 鼠标焦点丢失
```

![](1.gif)

### 解决方案

```js
1. ie / 火狐下 我们可以使用一个方法 把盒子和 指针绑定在一起
2. 在鼠标抬起的时候 我们在解绑
```

```js
const down = function (ev) {
    let {
        top,
        left
    } = this.getBoundingClientRect()
    this.startT = top
    this.startL = left
    this.startX = ev.clientX
    this.startY = ev.clientY   
    //ie 下 解决焦点丢失问题
    this.setCapture()
    this.addEventListener('mousemove',move)
    this.addEventListener('mouseup',up)
}

//抬起的时候 我们在解绑
const up = function() {
    //ie下然后移除
    this.releaseCapture()
    this.removeEventListener('mousemove',move)
    this.removeEventListener('mouseup',up)
}
```

```js
// 谷歌下 我们直接移动和 抬起 直接绑定给window  解绑的时候 也是一样 但是要注意this的指向问题 

let box = document.getElementById('box')
    //4. 拿到了一屏幕的高度和宽度
    HTML = document.documentElement
    //4. 设置了边界
    minL = 0
    minT = 0
    maxL = HTML.clientWidth - box.offsetWidth
    maxT = HTML.clientHeight - box.offsetHeight

const down = function (ev) {
    let {
        top,
        left
    } = this.getBoundingClientRect()
    this.startT = top
    this.startL = left
    this.startX = ev.clientX
    this.startY = ev.clientY   
  	//3.所以 我们要把这个函数保存一下解绑的时候也放便
  	this._move = move.bind(this)
  	this._up = up.bind(this)
  	//1. 为了 解决光标焦点丢失的问题 我们直接绑定给window 并且确保this指向正确
    // window.addEventListener('mousemove',move.bind(this))
    // window.addEventListener('mouseup',up.bind(this))
    window.addEventListener('mousemove',this._move)
    window.addEventListener('mouseup',this._up)
}
const move = function(ev){
    let curL = ev.clientX - this.startX + this.startL
        curT = ev.clientY - this.startY + this.startT
    curL = curL < minL ? minL : (curL > maxL?maxL:curL)
    curT = curT < minT ? minT : (curT > maxT?maxT:curT)

    this.style.left = curL + 'px'
    this.style.top = curT + 'px'
}
const up = function() {
    //2. 但是我们移除的时候会有问题 因为 我们使用了bind 它返回一个匿名函数 所以我们移除的时候 在移除move 就不对了 我们需要移除那个匿名函数
    //window.removeEventListener('mousemove',move)
    //window.removeEventListener('mouseup',up)
    //4. 解绑的时候 我们直接找到我们this上的方法就好了
  	window.removeEventListener('mousemove',this._move)
    window.removeEventListener('mouseup',this._up)
}
box.addEventListener('mousedown',down)
```

## 地址

```js
https://github.com/wazer1987/Drag
```


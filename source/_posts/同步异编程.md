---
title: 同步异步编程
date: 2019-03-29
updated: 2019-06-03
tags: JavaScript 
categories: JS高级
keywords: JS高级
description: JS高级
top_img:
comments: false
cover:
toc:
toc_number:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---

# 同步异步编程

## 进程/线程

```js
1. 进程代表一个程序 (浏览器开一个页卡就是一个进程)
2. 线程是用了处理进程种的具体事物的 如果一个程序种需要 同时做好多事 就需要开启多个线程
3. 浏览器是多线程的 -> CUI渲染线程 HTTP网络线程 JS渲染线程 监听线程
4. js 是单线程的 因为浏览器只分配了一个线程用来处理渲染JS代码  一个线程同时只能做一个事情
5. js种代码 大部分都是 同步编程  上面任务没有处理完成 下面的任务是无法处理的
6. 但是js中 利用浏览器的多线程机制 可以规划出异步编程效果
```

### 异步编程有哪些

```js
定时器  ajax/Fetch/跨域(HTTP网络请求) 事件绑定 Promise Generator yeild async await
```

## 底层机制

### 计算程序执行事件(预估)

```js
//大O表示法 提前预估的方法 O1 < O
//运行监控 console.time/timeEnd (受当前电脑运行的影响)
console.time('AAA')
for(let i = 0; i < 9999999; i++){
    //同步编程
}
console.timeEnd('AAA') //这里就会输出程序运行的时间
```

### 定时器的异步编程

```js
// 首先设置定时器任务是同步的 间隔 interval这么长时间 执行定时器绑定的函数(这个任务是异步的)
遇到异步任务 浏览器不会等待它执行完 则会继续渲染下面的代码
当等到下面代码运行完 时间也到了执行条件 才执行
setTimeout(() => {
    console.log('ok') // 1S之后输出
},1000)
console.log('NO') // 最先输出
// interval 为 0 也不是立即执行 浏览器都有最快反应时间 谷歌(5~6ms) IE(13~17ms) 即使设置为零 最快也要等 5ms
setTimeout(() => {
    console.log('ok') 
},0)
console.log('NO')
```

### 异步任务执行机制

```js
1. 首先我们都是在代码执行的时候 会开辟一个栈内存 代码执行生成上下文(EC(G)) 然后由渲染进程去执行这段代码
2. 代码分为同步代码 和 异步代码(比如我们的定时器  事件处理函数 ... 等等 )
3. 为了存放这些异步的代码(任务) 浏览器初始化加载页面的时候  会开启一个 任务队列(优先级队列) 用来存放我们的异步任务 就是你写在定时器里 或者 ajax promise .. 等等代码 然后由 浏览器开启一个监听线程 去监听你的异步任务 比如定时器到没到事件   请求的数据回来没回来
4. 这个任务队列(event queue) 分为两块 一个是微任务队列(microtask) 一个是宏任务队列(macrotask) 宏任务队列用来存放我们的定时器里面的任务代码 微任务队列存放我们的promise等等把
5. 然后开始从上到下执行代码 遇到一段代码 一看 是一个定时器 那么就把他存放宏任务队列里 并且开始计时
6. 等我们的同步代码 执行完毕 或者其他代码执行完毕  我们的js渲染线程空闲下来 才会去我们的任务队列看看 还有没有没执行的代码 反过来讲只要我们的同步代码没有执行完毕 哪怕你定时器已经到时间了也不会执行  
7. 同步代码执行完毕  就去任务队列看 还有没有 没有执行的代码 拿出来执行 首先回去看任务队列中的微任务队列 里有没有代码没执行 如果有 拿出来 当同步代码执行 等到执行完毕 在去看看 微任务队列里还有没有没执行的代码 如果有 在拿出来 当同步代码执行 如果没有 就去宏任务队列去看  如此反复的循环 这个方式叫做 eventLoop 事件循环
8. 这里定时器的宏任务执行顺序是 最先到时间的去执行
```

```js
//实例
setTimeout(() => {
    console.log(1); // 8.输出1
}, 20);
console.log(2); //1.输出2
setTimeout(() => {
    console.log(3); // 7.输出3
}, 10);
console.log(4); //2.输出4
console.time('AA');
for (let i = 0; i < 90000000; i++) {
    // do soming
}
console.timeEnd('AA'); //=>AA: 79ms 左右 //3.输出80ms
console.log(5); //4.输出5
setTimeout(() => {
    console.log(6); // 9.出书6
}, 8);
console.log(7); //5.输出7 
setTimeout(() => {
    console.log(8); // 10.出书8
}, 15);
console.log(9); //6.输出8
```

![](eventLoop.png)

```js
以上代码解析 
首先就去执行我们的同步代码 但在执行过程之后 有个循环 总过经过了 80ms 在循环的过程中 我们的 第二个定时器 第一个定时器 已经到时间 但是我们的主线程还没有执行完毕 所以js渲染线程没有空下来 即使我们 定时器到时间 也不会执行 
循环结束之后 代码往下执行 遇到两个定时器 接着 放在我们的宏任务里 代码执行完毕 
然后我们js渲染线程就空下来了 此时就去任务队列里看 还有没有任务没执行 看到宏任务里 由于 第二个定时器是先到时间的 所以就先执行 然后执行 第一个定时器   由于我们第三个定时器 和第四个定时 是在我们循环结束之后 才开始开启的 所以要最后执行
```

## 基础数据结构之队列和栈

### 栈结构

```js
1. 栈结构(LIFO last in first out)的特点  先进后出  或者 后进先出 
2. 所有的操作只能在一端操作(顶端) 包括增加(进栈) 和 删除(出栈)
3. 递归算法中的无限递归会出现栈溢出
```

![](栈结构.gif)

### 实现一个栈结构

```js
1. 以后创建一个栈 就是创建一个栈的实例
2. 要有个容器 
```

```js
class Stack {
    container = []
	//进栈的方法
	enter(valye) {
        //把元素插入到最顶端
        this.container.unshift(value)
    }
	// 出栈
	leave() {
        // 从最顶端删除元素
        return this.container.shift()
    }
	// 尺寸
	size(){
        return this.container.length
    }
	// 栈里有哪些东西
	value(){
        // 把元素都克隆一份
        return this.container.slice(0)
    }
}
```

### 十进制转二进制

```JS
1. Number.prototype.toString('进制数') 可以取的转换后的进制数
2. 第二个方法 就是短除法
```

```js
// 短除法 比如求 63 的 二进制
63 / 2  商 31 剩 1
31 / 2  商 15 剩 1
15 / 2  商 7  剩 1
7  / 2  商 3  剩 1
3  / 2  商 1  剩 1
1  / 2  商 0  剩 1
// 然后把我们的剩数 从下向上 相加 就是二进制
63的二进制数 是 111111
```

```js
// 我们利用短除法 写代码
Number.prototypt.decimal2binary = function () {
    // 这里面的this 就是我们的num 是个引用类型 new Number
    // 这里我们可以先用valueOf()获取原始值 也可以不用 因为在参与运算的时候 自己就会转换
    let decimal = this
    //这个是我们上面写的栈结构的类
    sk = new Stack
    if(decimal === 0) return '0'
    //然后开始循环 思想就是我们上面的短除法 每次的商 在除2 每次取的余数 都进栈
    while(decimal > 0) {
        //每次的商
        let n = Math.floor(decimal / 2)
        //每次的余数
            m = decimal % 2
        //把余数进栈
        sk.enter(m)
        // 然后让我们下次的除2的数 等于我们 上次的商数
        decimal = n
    }
    // 最后把我们的进栈的的元素 变成字符串 因为是栈结构 所以我们最先进去的余数在最下面 最后进去的余数 在最上面
    return sk.value().join('')
}
let num = 187956
num.decimal2binary()
```

### 队列结构

```js
1. 队列结构 和我们的栈结构相反 是先进先出 分进入队列 和移除队列
2. 允许在前端 删除 允许在后端插入
3. 特点 优先级队列
4. 可以想象成 从 尾巴进入 从 头中出去
5. 队列的特点 也是有优先级的 并不是 谁最后进来 谁进放在末尾 而是谁的优先级最高 谁就放在前面  
```

![](队列.gif)

```js
// 队列类
class Queue {
    container = []
	//进栈的方法
	enter(valye) {
        //把元素插入到最顶端
        this.container.push(value)
    }
	// 出栈
	leave() {
        // 从最顶端删除元素
        return this.container.shift()
    }
	// 尺寸
	size(){
        return this.container.length
    }
	// 栈里有哪些东西
	value(){
        // 把元素都克隆一份
        return this.container.slice(0)
    }
}
```

```js
// 比较优先级
// 队列类
class Queue {
    container = []
	//进栈的方法
	enter(value,priority = 0) {
        // priority 默认优先级为 0
       let obj = {value,priority}
       // 如果你的优先级是0 了 那么我就直接把你放在容器的末尾
       if(priority === 0) {
           this.container.push(obj)
           return 
       }
       let flag = false
       //如果不是 我就和我最前面的比  如果比他高就放他前面
       for(let i = this.container.length - 1; i >= 0; i--){
           let item = this.container[i]
           // 对比所有的优先级 找到 比你高一级的元素
           if(item.priority >= priority){
               // 找到了 就放在比你高一级元素的后面
               this.container.splice(i,0,obj)
               //然后证明找到
               flag = true
               //结束循环
               break
           }
       }
        //如果没找到 就说明你优先级是最低的 就放在最后面
        !flag? this.container.push(obj) : null
    }
	// 出栈
	leave() {
        // 从最顶端删除元素
        return this.container.shift()
    }
	// 尺寸
	size(){
        return this.container.length
    }
	// 栈里有哪些东西
	value(){
        // 把元素都克隆一份
        return this.container.slice(0)
    }
}
```

### 击鼓传花

```js
N 个人一起玩游戏 围成一圈 从 1 开始数树 数到M的人 自动淘汰 最后剩下的人 会取的胜利 问最后剩下的是谁
比如有8个人 开始数数 数到 5 的人淘汰 然后在开始下一轮 数到5的人 在淘汰 看最后剩下谁
```

```js
// 原理
 1 2 3 4 5 6 7 8
开始数数 第一个人数1 数完之后 排到 8 后面  第2个数完 排到 1  后面 依次类推 第 5 个人数到 5 了淘汰 
第二轮 6 是第一个 数1 数完之后 拍到4后面 7 数 2 拍到 6 后面 然后数到5的淘汰
... 以上 依次类推 看看 最后剩下谁
```

```js
function game (n,m) {
    let qe = new Queue
    //先让八个人都进入队列
    for(let i = 0,i < n; i++){
        qe.ennter(n)
    }
    //然后开始数数 结束条件就是 队列里最后只剩一个人了
    while(qe.size() > 1){
        for(let i = 0; i < m -1; i++){
            qe.enter(qe.leave())
        }
        qe.leave()
    }
    return qe.value().toString()
}
// 一共 8个人  数到5 的淘汰
game(8,5)
```




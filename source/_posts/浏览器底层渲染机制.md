---
title: 浏览器底层渲染机制
date: 2019-03-22
updated: 2019-06-03
tags: web 
categories: 前端性能优化
keywords: 前端性能优化
description: 前端性能优化
top_img:
comments: false
cover:
toc:
toc_number:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---

# 浏览器底层渲染机制

## 打开页面输入网址

```js
1. 客服端会从服务器获取需要渲染页面的源代码
2. 然后开辟一个GUI渲染线程 自上而下解析代码 最后绘制出对应的页面
```

## 关于CSS资源加载

```js
1. 遇到的是偶 <style> 内嵌样式 由于这些直接就在我们源代码上 所以直接 就同步的 交给GUI渲染线程解析
2. 如果遇到 <link> 外链样式 就会在开辟一个 HTTP网络资源请求线程 不等到 我们link标签的资源请求回来 GUI渲染线程继续向下渲染
3. 等到GUI渲染线程同步 也就是自上向下的操作都处理完成后 再把基于HTTP网络线程请求回来的资源 文件进行解析渲染
4. @import 导入样式 也会从服务器获取资源 也会开辟一个HTTP请求显现 去请求资源文件 但是他是同步的 需要等到import 请求的资源回来之后 GUI 才会向下走 一般不会用这这种方式
5. 向link这里 在同一个源下 高性能浏览器 HTTP请求线程最多可以开辟 6-7个 而低版本 4-7个 这种我们叫做并发数
```

## 关于script加载

```js
1. 遇到script 资源请求 默认都是同步的 必须基于 HTTP网络线程 把资源请求回来之后 并且 交给JS渲染线程 解析完毕之后 GUI渲染线程才能向下走  所以 script 也会阻碍GUI渲染
2. 这里要排除 JS 脚本中的异步
3. 这里也可以 把script 变成异步的 async属性
4. <script async> 首先也是开辟一个HTTP网络线程去加载资源文件(异步的) 与此同时 GUI 还会向下解析代码 但是一旦资源请求回来之后 会通过中断 GUI 正在渲染的东西 然后优先渲染 script 请求回来的东西 如果多个 这样的 script async 那么谁先回来 就加载谁
5. <script defer>  首先也会开辟一个HTTP网络请求线程去请求资源文件(异步) 与此同时 GUI还会向下解析 如果此时我们defer请求的资源已经请求回来了 GUI不会中断 会继续渲染解析下面同步的代码 等到 同步的代码都已经 解析完毕了 我才去解析你 defer 请求回来的代码  如果右多个 script defer 那么会按照顺序 去 加载谁
```

![](1.png)

## 关于 img 或者 音视频资源

```js
1. 遇到这些资源(异步) 也会开辟一个 HTTP网络线程 然后请求资源 GUI继续 向下解析 当GUI渲染解析完毕之后 在去渲染图片 和音视频 
```

## 预加载

```js
Webkit浏览器预测解析：chrome的预加载扫描器html-preload-scanner通过扫描节点中的 “src” , “link”等属性，找到外部连接资源后进行预加载，避免了资源加载的等待时间，同样实现了提前加载以及加载和执行分离。
1. 主要就是 源代码请求回来的 我们先总体看一下代码 中的 src 或者link 然后就赶紧该请求就去请求 
2. 然后才开始 GUI 渲染解析
```

## 页面渲染步骤

```js
1. DOM TREE(DOM树) : 自上而下渲染完页面 整理好整个页面DOM结构关系 
2. CSSOM TREE (样式树) 当把所有的样式资源请求加载回来后 按照 引入CSS的顺序 依次渲染样式代码生成样式树
3. RENDER TREE (渲染树) 把生成的DOM树和CSSOM树结合在一起 生成 渲染树 (样式为display：none的不进行渲染)
```

### DOM树

![](DOM树.png)

### CSSOM树

![](CSSOM树.png)

### RENDER树

![](render树.png)

```js
1. 请求回来的源代码之后 GUI渲染线程 从下向上 解析代码  解析完毕之后 生成DOM TREE
2. 在解析的过程中 遇到 多个 link 标签 就去开辟一个一个HTTP请求 异步的请求CSS资源会
3. 等到请求回来之后 GUI 在去 解析你link 请求回来的资源 也是按顺序的去解析的 
4. 然后最后把 DOM 和 CSSOM 合并成 render Tree
5. 如果有些资源 加载的特别特别慢 就会忽略 不会一直等 直接生成 render tree
```

### render tree 生成页面

```js
1. layout 布局(页面) 根据 render tree  计算他们在设备视口内的确切位置和大小 这个计算阶段就是回流 -> 布局 或者 重排 回流
2. 分层处理 根据我们的样式 会把DOM元素 分层处理 每一层里面都会有绘画的规则(样式)
3. 进行渲染(绘制) Painting(重绘) 按照每一个层级的计算处理的绘制步骤 -> 其中还包含 图片绘制 
4. 以上完毕之后 就能看到整个页面了
```

![](rendertree.png)

### 性能优化 CRP:关键渲染路径

```js
1. 一种性能优化的指标
2. 生成DOM tree 优化 DOM的节点  层级不要太深 因为 词法解析的时候 需要把你DOM 和 DOM 之间的层级关系计算出了 而且 不要使用 非标准标签
3. 生成CSSOM树 尽可能不要使用@import(会阻塞GUI渲染) 如果CSS代码比较少 尽可能 使用 style 内嵌式  减少了从网路上获取资源 因为你DOM树生成完了 要生成 render 树 CSS资源还没回来呢
4. CSS 选择器 链路短一些(因为CSS 选择器 渲染是从右到左的)
.nav a{} 和 a{} 这两个选择器 第一个需要筛选两次 第二个只需要筛选一个 从右向左 首先先选中a 然后在选中 nav 下的 a
5. 如果使用LINK 尽可能 把所有的样式资源 合并为一个CSS 减少HTTP 请求的次数  而且 尽量把 link 等导入CSS 的操作 放在 HEAD 中(目的是 一加载页面就开始请求资源)
```

### 性能优化 script

```js
1. 尽可能把 标签 放在页面底部 body 部位 防止它 阻塞GUI渲染 对于部分 script 要使用 async defer
```

### 性能优化 img

```js
1. 主要方式就是懒加载 第一次加载页面的时候 不要 加载请求图片 哪怕他是异步的 但是也占据了HTTP并发数量 导致其他资源要延后请求
2. 可以使用图片 base64 基本上不去请求加载图片 而且图片渲染的时候也很快(不过要慎用 因为代码两很多)
```

### 性能优化 减少Layout(回流、重拍)/Painting(重绘)

```js
1. 第一次加载页面的时候 必然会有依次回流和重绘
2. 触发回流后 必然 也会触发重绘  如果只是单纯的重绘 不一定会引发回流
```

```js
1. 回流/重拍 就是分析了元素所在的位置 和 大小 还有分层 所以 当元素的大小 位置 (当页面的布局和几何信息发生了变化的时候) 就会触发回流 和 重拍 因为你的位置 和 大小改变了 就需要浏览器 重新计算渲染和布局 比如你拉动浏览器的视口之后 元素的大小就会改变 所以就需要重新计算
```

### 当代浏览器的渲染队列机制

```js
在当前上下文操作中 遇到一行修改样式的代码 并没有立即通知浏览器渲染 而是把其放在渲染队列中 接下来 看是否还有修改样式的代码 如果有继续放在在渲染队列中 一直到再也没有 修改样式的代码 或者 遇到一行获取样式的操作 然后渲染队列 就会通知浏览器 渲染 这样的好处 是 只会触发一次回流 重拍
```

```js
1. 我们浏览器 在重新渲染元素的时候 会从 渲染队列里面去看看哪些渲染任务已经完成了
2. 而这些渲染任务 就在渲染队列里 
3. 比如我们一个元素的 宽高定位 改变了 他不会 立即就渲染 而是先一步一步 把改变宽 存放在渲染队列里 然后改变高 然后 改变定位 依次的放在渲染队列里 
4. 等到这个元素 没有在改变 几何数据的时候 然后通知页面 渲染
5. 在改变元素的途中 如果有获取样式 操作 如 box.style getComputedStyle clientWidth ouffset系列等 这样操作都会刷新 渲染队列机制 就是让渲染队列里已经有的任务 通知浏览器渲染 然后在重新 放进去任务
6. 基于上面 我们知道 改变样式之后 就获取了样式 会刷新渲染队列 触发了回流冲怕 所以我们尽量在些样式的时候 要采用分离独写  把改变样式的代码  和 获取 样式的代码 分开写
7. 也可以采用 box.style.cssText = 'width:100px;heigt:200px;' 这样就是 把写样式统一都写在了一起
```

```js
1.我们在创建元素 和新增元素的时候 也会引发回流
```

```js
let arr  = ['张三','李四','王五']
arr.forEach( item => {
    let span = document.createElement('sapn')
    span.innerText = item
    document.body.appendChild(span)
})
// 有上会引发三次回流 重拍
```

```js
// 所以我们可以如下写 但是也会存在问题 可能因为页面中 把原始容器的的内容变成字符串拼接
let str = ''
arr.forEach( item => {
    str += `<sapn>${item}</span>`
})
document.body.innerHTML	 = str
```

```js
// 还有一种方式叫文档碎片 向当于一个文档碎片
let frag = document.createDocumentFragment()
arr.forEach( item => {
    let span = document.createElement('sapn')
    span.innerText = item
    frag.appendChild(span)
})
document.body.appendChild(frag)
frag = null
```

```js
把动画等频发样式改变操纵  运用到 postition:fixed/absolute 上 脱离文档流 自己变成独立一层
这样 如果发生 回流和重拍 那么只处理计算 自己这一层
```

```js
修改元素的 transform / opacity(filters) 这种会体改CSS 硬件加速  不会引发DOM回流 弊端就是消耗浏览器内存
```

